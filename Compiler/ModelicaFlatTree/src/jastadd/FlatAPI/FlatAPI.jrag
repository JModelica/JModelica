/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.HashSet;
import java.util.Set;
import java.util.ArrayList;
import java.util.EnumMap;
import java.io.File;
import java.math.BigInteger;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.DigestOutputStream;
import java.security.NoSuchAlgorithmException;

import org.jmodelica.common.GUIDManager;
import org.jmodelica.util.streams.StreamGobbler;

aspect FlatAPI {

    public class FClass {
        
        /**
         * Enum like object which represents the most specific categorisation
         * of a variable that is represented in our z-vector.
         */
        public static interface ZCategory {
            public static final ZCategory TIME = 
                    new FixedSizeCategory("TIME", "t", "time");
            public static final ZCategory HOMOTOPY_LAMBDA = 
                    new FixedSizeCategory("HOMOTOPY_LAMBDA", "homotopy_lambda", "_homotopy_lambda");
            
            public ZStructVector zStructVector();
            public String zOffsetName();
            public ZCategoryEntry createEntry(Collection<FVariable> vars, Enumerator enumerator, Integer offset);
            public Comparator<FVariable> sorter(Collection<FVariable> vars, FClass fclass);
            public int valueReferenceFromIndex(int index);
            public void visitZOrder(ZVisitor v);
        }
        
        /**
         * A visitor for visiting each variable in Z order.
         */
        public static interface ZVisitor {
            public void visitVariable(FVariable fv, ZCategoryEntry entry);
            public void visitVirtualVariable(String name, String zOffsetName, int offset);
        }

        /**
         * Implementation of ZCategory used by special constructs such as
         * time and homotopy lambda.
         */
        public static class FixedSizeCategory implements ZCategory {
            private final int size;
            private final String name;
            private final String zOffsetName;
            private final String[] memberNames;

            public FixedSizeCategory(String name, String zOffsetName, String... memberNames) {
                this.size = memberNames.length;
                this.name = name;
                this.zOffsetName = zOffsetName;
                this.memberNames = memberNames;
            }

            @Override
            public ZStructVector zStructVector() {
                return ZStructVector.DEFAULT;
            }

            @Override
            public ZCategoryEntry createEntry(Collection<FVariable> vars, Enumerator enumerator, Integer groupOffset) {
                if (vars.size() > 0) {
                    throw new IllegalArgumentException("Special z index categories are not allowed to have entries!");
                }
                return new ZCategoryEntry(this, size, enumerator, groupOffset);
            }

            @Override
            public Comparator<FVariable> sorter(Collection<FVariable> vars, FClass fclass) {
                return null;
            }

            @Override
            public String toString() {
                return name;
            }

            @Override
            public String zOffsetName() {
                return zOffsetName;
            }

            @Override
            public int valueReferenceFromIndex(int index) {
                return index;
            }

            @Override
            public void visitZOrder(ZVisitor v) {
                for (int i = 0; i < size; i++) {
                    v.visitVirtualVariable(memberNames[i], zOffsetName, i);
                }
            }

        }

        /**
         * Used for specifying which z-vector is used for enumerating the
         * specific variable category.
         */
        public static enum ZStructVector {
            DEFAULT,
            STRING,
            EXTERNAL
        }

        /**
         * Used in when specifying category for parameters (and constants).
         * Parameters can be either independent or dependent. Dependent
         * parameters are those which are calculated by a binding expression
         * which references other parameters.
         * 
         * Currently there is only independent constants.
         */
        public static enum ParaDependency {
            INDEPENDENT ("i"),
            DEPENDENT   ("d");

            private final String zOffsetName;

            private ParaDependency(String zOffsetName) {
                this.zOffsetName = zOffsetName;
            }

            public String zOffsetName() {
                return zOffsetName;
            }
        }

        /**
         * Enum like object which represents the different variable types we
         * have in our z-vector.
         * 
         * Can't be enum since we wan't to use generics. Makes list retrieval
         * easier!
         */
        public static enum ZType {
            REAL,
            INTEGER   (1 << 28),
            BOOLEAN   (2 << 28),
            ENUM      (1 << 28, "integer"),
            STRING    (3 << 28, ZStructVector.STRING),
            EXTERNAL  (0, ZStructVector.EXTERNAL);

            private final int valueReferenceMask;
            private final ZStructVector zStructVector;
            private final String zOffsetName;

            private ZType() {
                this(0);
            }

            private ZType(int valueReferenceMask) {
                this(valueReferenceMask, ZStructVector.DEFAULT);
            }

            private ZType(int valueReferenceMask, String zOffsetName) {
                this(valueReferenceMask, ZStructVector.DEFAULT, zOffsetName);
            }

            private ZType(int valueReferenceMask, ZStructVector zStructVector) {
                this(valueReferenceMask, zStructVector, null);
            }

            private ZType(int valueReferenceMask, ZStructVector zStructVector, String zOffsetName) {
                this.valueReferenceMask = valueReferenceMask;
                this.zStructVector = zStructVector;
                this.zOffsetName = (zOffsetName != null) ? zOffsetName : toString().toLowerCase();
            }

            public ZStructVector zStructVector() {
                return zStructVector;
            }

            /**
             * Takes a variable index and adds the types valuereference mask
             */
            public int mask(int index) {
                return index ^ valueReferenceMask;
            }

            public String calcZOffsetName(ZVariability var, ParaDependency dependency) {
                if (this == EXTERNAL) {
                    return zOffsetName;
                } else {
                    return String.format(var.zOffsetNameFormat(), zOffsetName, dependency.zOffsetName());
                }
            }

        }

        /**
         * Represents the different variabilities that are possible in the z-vector
         */
        public static enum ZVariability {
            CONSTANT        ("c%s"),
            REGULAR_PARAMETER,
            STRUCTURAL_PARAMETER,
            FINAL_PARAMETER,
            EVAL_PARAMETER,
            FREE_PARAMETER, // Only for Optimica!
            INITIAL_PARAMETER,
            DISCRETE        ("d"),
            INPUT           ("u"),
            DIFFERENTIATED  ("x"),
            DERIVATIVE      ("dx"),
            CONTINUOUS      ("w");

            private final boolean isParameter;
            private final String zOffsetNameFormat;

            private ZVariability() {
                this("p%s", true);
            }

            private ZVariability(String zOffsetName) {
                this(zOffsetName, false);
            }

            private ZVariability(String zOffsetName, boolean isParameter) {
                this.isParameter = isParameter;
                this.zOffsetNameFormat = "%s_" + zOffsetName;
            }

            public boolean isParameter() {
                return isParameter;
            }

            public String zOffsetNameFormat() {
                return zOffsetNameFormat;
            }
        }

        /**
         * Class representing ordinary z-vector categories.
         */
        public static class ZOrdinaryCategory implements ZCategory {
            private final static Map<Integer, ZOrdinaryCategory> lookupMap = new HashMap<Integer, ZOrdinaryCategory>();
            
            private static ZOrdinaryCategory create(ParaDependency dependency, ZType type, ZVariability variability) {
                ZOrdinaryCategory category = new ZOrdinaryCategory(dependency, type, variability);
                return category;
            }

            public static final ZOrdinaryCategory INDEPENDENT_REAL_CONSTANT                = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.CONSTANT);
            public static final ZOrdinaryCategory DEPENDENT_REAL_CONSTANT                  = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.CONSTANT);
            public static final ZOrdinaryCategory INDEPENDENT_REAL_REGULAR_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_REAL_STRUCTURAL_PARAMETER    = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_REAL_FINAL_PARAMETER         = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_REAL_EVAL_PARAMETER          = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_REAL_FREE_PARAMETER          = create(ParaDependency.INDEPENDENT, ZType.REAL,    ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_REAL_REGULAR_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_REAL_STRUCTURAL_PARAMETER      = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_REAL_FINAL_PARAMETER           = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_REAL_EVAL_PARAMETER            = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_REAL_FREE_PARAMETER            = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory REAL_INITIAL_PARAMETER                   = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.INITIAL_PARAMETER);

            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_CONSTANT             = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.CONSTANT);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_CONSTANT                = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.CONSTANT);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_CONSTANT               = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.CONSTANT);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_CONSTANT                  = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.CONSTANT);
            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_REGULAR_PARAMETER    = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_REGULAR_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_STRUCTURAL_PARAMETER = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_STRUCTURAL_PARAMETER    = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_FINAL_PARAMETER      = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_FINAL_PARAMETER         = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_EVAL_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_EVAL_PARAMETER          = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_INTEGER_FREE_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.INTEGER, ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_ENUM_FREE_PARAMETER          = create(ParaDependency.INDEPENDENT, ZType.ENUM,    ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_REGULAR_PARAMETER      = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_REGULAR_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_STRUCTURAL_PARAMETER   = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_STRUCTURAL_PARAMETER      = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_FINAL_PARAMETER        = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_FINAL_PARAMETER           = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_EVAL_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_EVAL_PARAMETER            = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_INTEGER_FREE_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_ENUM_FREE_PARAMETER            = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory INTEGER_INITIAL_PARAMETER                = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.INITIAL_PARAMETER);
            public static final ZOrdinaryCategory ENUM_INITIAL_PARAMETER                   = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.INITIAL_PARAMETER);

            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_CONSTANT             = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.CONSTANT);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_CONSTANT               = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.CONSTANT);
            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_REGULAR_PARAMETER    = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_STRUCTURAL_PARAMETER = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_FINAL_PARAMETER      = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_EVAL_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_BOOLEAN_FREE_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.BOOLEAN, ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_REGULAR_PARAMETER      = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_STRUCTURAL_PARAMETER   = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_FINAL_PARAMETER        = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_EVAL_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_BOOLEAN_FREE_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.FREE_PARAMETER);
            public static final ZOrdinaryCategory BOOLEAN_INITIAL_PARAMETER                = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.INITIAL_PARAMETER);

            public static final ZOrdinaryCategory INDEPENDENT_STRING_CONSTANT              = create(ParaDependency.INDEPENDENT, ZType.STRING,  ZVariability.CONSTANT);
            public static final ZOrdinaryCategory DEPENDENT_STRING_CONSTANT                = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.CONSTANT);
            public static final ZOrdinaryCategory INDEPENDENT_STRING_REGULAR_PARAMETER     = create(ParaDependency.INDEPENDENT, ZType.STRING,  ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_STRING_STRUCTURAL_PARAMETER  = create(ParaDependency.INDEPENDENT, ZType.STRING,  ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_STRING_FINAL_PARAMETER       = create(ParaDependency.INDEPENDENT, ZType.STRING,  ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory INDEPENDENT_STRING_EVAL_PARAMETER        = create(ParaDependency.INDEPENDENT, ZType.STRING,  ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_STRING_REGULAR_PARAMETER       = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_STRING_STRUCTURAL_PARAMETER    = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.STRUCTURAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_STRING_FINAL_PARAMETER         = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.FINAL_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_STRING_EVAL_PARAMETER          = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.EVAL_PARAMETER);
            public static final ZOrdinaryCategory STRING_INITIAL_PARAMETER                 = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.INITIAL_PARAMETER);

            public static final ZOrdinaryCategory INDEPENDENT_EXTERNAL_OBJECT              = create(ParaDependency.INDEPENDENT, ZType.EXTERNAL,ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory DEPENDENT_EXTERNAL_OBJECT                = create(ParaDependency.DEPENDENT,   ZType.EXTERNAL,ZVariability.REGULAR_PARAMETER);
            public static final ZOrdinaryCategory EXTERNAL_OBJECT_INITIAL_PARAMETER        = create(ParaDependency.DEPENDENT,   ZType.EXTERNAL,ZVariability.INITIAL_PARAMETER);

            public static final ZOrdinaryCategory REAL_INPUT                               = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.INPUT);
            public static final ZOrdinaryCategory INTEGER_INPUT                            = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.INPUT);
            public static final ZOrdinaryCategory ENUM_INPUT                               = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.INPUT);
            public static final ZOrdinaryCategory BOOLEAN_INPUT                            = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.INPUT);
            public static final ZOrdinaryCategory STRING_INPUT                             = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.INPUT);

            public static final ZOrdinaryCategory DISCRETE_REAL                            = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.DISCRETE);
            public static final ZOrdinaryCategory DISCRETE_INTEGER                         = create(ParaDependency.DEPENDENT,   ZType.INTEGER, ZVariability.DISCRETE);
            public static final ZOrdinaryCategory DISCRETE_ENUM                            = create(ParaDependency.DEPENDENT,   ZType.ENUM,    ZVariability.DISCRETE);
            public static final ZOrdinaryCategory DISCRETE_BOOLEAN                         = create(ParaDependency.DEPENDENT,   ZType.BOOLEAN, ZVariability.DISCRETE);
            public static final ZOrdinaryCategory DISCRETE_STRING                          = create(ParaDependency.DEPENDENT,   ZType.STRING,  ZVariability.DISCRETE);

            public static final ZOrdinaryCategory DIFFERENTIATED                           = new ZOrdinaryCategory(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.DIFFERENTIATED) {
                /**
                 * This is needed since optimization and some simulation models
                 * are extremely picky about the order of the states!
                 */
                @Override
                public Comparator<FVariable> sorter(Collection<FVariable> vars, FClass fclass) {
                    final Map<FVariable, Integer> posMap = new HashMap<FVariable, Integer>();
                    int i = 0;
                    for (FVariable var : fclass.differentiatedByFDerExp()) {
                        posMap.put(var,  i++);
                    }
                    return new Comparator<FVariable>() {
                        @Override
                        public int compare(FVariable a, FVariable b) {
                            Integer aPos = posMap.get(a);
                            if (aPos == null) {
                                throw new InternalCompilerError("Unable to determine index for differentiated variable " + a);
                            }
                            Integer bPos = posMap.get(b);
                            if (bPos == null) {
                                throw new InternalCompilerError("Unable to determine index for differentiated variable " + b);
                            }
                            return aPos - bPos;
                        }};
                };
            };
            public static final ZOrdinaryCategory DERIVATIVE                               = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.DERIVATIVE);
            public static final ZOrdinaryCategory CONTINUOUS                               = create(ParaDependency.DEPENDENT,   ZType.REAL,    ZVariability.CONTINUOUS);

            public final ParaDependency dependency;
            public final ZType type;
            public final ZVariability variability;
            private final String zOffsetName;

            /**
             * Use create method instead!
             */
            private ZOrdinaryCategory(ParaDependency dependency, ZType type, ZVariability variability) {
                this.dependency = dependency;
                this.type = type;
                this.variability = variability;
                this.zOffsetName = type.calcZOffsetName(variability, dependency);
                lookupMap.put(computeLookupKey(this), this);
            }

            @Override
            public ZStructVector zStructVector() {
                return type.zStructVector();
            }

            @Override
            public String zOffsetName() {
                return zOffsetName;
            }

            @Override
            public int valueReferenceFromIndex(int index) {
                return type.mask(index);
            }

            @Override
            public void visitZOrder(ZVisitor v) {}

            @Override
            public ZCategoryEntry createEntry(Collection<FVariable> vars, Enumerator enumerator, Integer groupOffset) {
                return new ZCategoryEntry(this, vars, enumerator, groupOffset);
            }

            private static int computeLookupKey(ZOrdinaryCategory category) {
                return computeLookupKey(category.dependency, category.type, category.variability);
            }

            private static int computeLookupKey(ParaDependency dependency, ZType type, ZVariability variability) {
                return dependency.hashCode() ^ type.hashCode() ^ variability.hashCode();
            }

            public static ZOrdinaryCategory resolve(FVariable var) {
                if (var == null || var.isPreVariable()) {
                    // Pre variables should be excluded!
                    return null;
                }
                ParaDependency dependency;
                if (var.isIndependentConstant() || var.isIndependentParameter()) {
                    dependency = ParaDependency.INDEPENDENT;
                } else {
                    dependency = ParaDependency.DEPENDENT;
                }
                ZType type = var.type().genType();
                ZVariability variability = var.zVariability();
                // If any of these are null, then this variable is not of
                // interest and should be ignored, indicate this with null.
                if (dependency == null || type == null || variability == null) {
                    return null;
                }
                return lookupMap.get(computeLookupKey(dependency, type, variability));
            }

            @Override
            public Comparator<FVariable> sorter(Collection<FVariable> vars, FClass fclass) {
                return null;
            }

            @Override
            public String toString() {
                return dependency + "_" + type + "_" + variability;
            }
        }

        /**
         * Manages value references for variables
         */
        public static class VarRefMap {
            private static final ZCategory[] zIndexOrder = new ZCategory[] {
                    ZOrdinaryCategory.INDEPENDENT_REAL_CONSTANT,
                    ZOrdinaryCategory.DEPENDENT_REAL_CONSTANT,
                    ZOrdinaryCategory.INDEPENDENT_REAL_REGULAR_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_REAL_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_REAL_FINAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_REAL_EVAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_REAL_FREE_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_REAL_REGULAR_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_REAL_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_REAL_FINAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_REAL_EVAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_REAL_FREE_PARAMETER,
                    ZOrdinaryCategory.REAL_INITIAL_PARAMETER,

                    ZOrdinaryCategory.INDEPENDENT_INTEGER_CONSTANT,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_CONSTANT,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_CONSTANT,
                    ZOrdinaryCategory.DEPENDENT_ENUM_CONSTANT,
                    ZOrdinaryCategory.INDEPENDENT_INTEGER_REGULAR_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_REGULAR_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_INTEGER_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_INTEGER_FINAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_FINAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_INTEGER_EVAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_EVAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_INTEGER_FREE_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_ENUM_FREE_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_REGULAR_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_ENUM_REGULAR_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_ENUM_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_FINAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_ENUM_FINAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_EVAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_ENUM_EVAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_INTEGER_FREE_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_ENUM_FREE_PARAMETER,
                    ZOrdinaryCategory.INTEGER_INITIAL_PARAMETER,
                    ZOrdinaryCategory.ENUM_INITIAL_PARAMETER,

                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_CONSTANT,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_CONSTANT,
                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_REGULAR_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_FINAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_EVAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_BOOLEAN_FREE_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_REGULAR_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_FINAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_EVAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_BOOLEAN_FREE_PARAMETER,
                    ZOrdinaryCategory.BOOLEAN_INITIAL_PARAMETER,

                    ZOrdinaryCategory.DERIVATIVE,
                    ZOrdinaryCategory.DIFFERENTIATED,
                    ZOrdinaryCategory.REAL_INPUT,
                    ZOrdinaryCategory.CONTINUOUS,

                    ZCategory.TIME,
                    ZCategory.HOMOTOPY_LAMBDA,

                    ZOrdinaryCategory.DISCRETE_REAL,

                    ZOrdinaryCategory.DISCRETE_INTEGER,
                    ZOrdinaryCategory.DISCRETE_ENUM,

                    ZOrdinaryCategory.INTEGER_INPUT,
                    ZOrdinaryCategory.ENUM_INPUT,

                    ZOrdinaryCategory.DISCRETE_BOOLEAN,
                    ZOrdinaryCategory.BOOLEAN_INPUT,

                    ZOrdinaryCategory.INDEPENDENT_STRING_CONSTANT,
                    ZOrdinaryCategory.DEPENDENT_STRING_CONSTANT,
                    ZOrdinaryCategory.INDEPENDENT_STRING_REGULAR_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_STRING_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_STRING_FINAL_PARAMETER,
                    ZOrdinaryCategory.INDEPENDENT_STRING_EVAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_STRING_REGULAR_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_STRING_STRUCTURAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_STRING_FINAL_PARAMETER,
                    ZOrdinaryCategory.DEPENDENT_STRING_EVAL_PARAMETER,
                    ZOrdinaryCategory.STRING_INITIAL_PARAMETER,

                    ZOrdinaryCategory.DISCRETE_STRING,
                    ZOrdinaryCategory.STRING_INPUT,

                    ZOrdinaryCategory.INDEPENDENT_EXTERNAL_OBJECT,
                    ZOrdinaryCategory.DEPENDENT_EXTERNAL_OBJECT,
                    ZOrdinaryCategory.EXTERNAL_OBJECT_INITIAL_PARAMETER,
            };

            private static final ZCategory[] zIndexOrderPre = new ZCategory[] {
                    ZOrdinaryCategory.DERIVATIVE,
                    ZOrdinaryCategory.DIFFERENTIATED,
                    ZOrdinaryCategory.REAL_INPUT,
                    ZOrdinaryCategory.CONTINUOUS,

                    ZOrdinaryCategory.DISCRETE_REAL,

                    ZOrdinaryCategory.DISCRETE_INTEGER,
                    ZOrdinaryCategory.DISCRETE_ENUM,

                    ZOrdinaryCategory.INTEGER_INPUT,
                    ZOrdinaryCategory.ENUM_INPUT,

                    ZOrdinaryCategory.DISCRETE_BOOLEAN,
                    ZOrdinaryCategory.BOOLEAN_INPUT,
                    
                    ZOrdinaryCategory.DISCRETE_STRING,
                    ZOrdinaryCategory.STRING_INPUT,
            };

            private final Map<ZCategory, ZCategoryEntry> categoryMap;

            public VarRefMap(Iterable<FVariable> vars, FClass fclass) {
                Map<ZCategory, java.util.List<FVariable>> varMap = new HashMap<>(zIndexOrder.length);
                Map<String, Integer> zOffsetMap = new HashMap<>(zIndexOrder.length);
                Map<ZStructVector, Enumerator> vectorEnumerators = new HashMap<>(zIndexOrder.length);
                for (ZCategory category : zIndexOrder) {
                    if (varMap.put(category, new ArrayList<FVariable>()) != null) {
                        throw new IllegalArgumentException("There are multiple entries for " + category + " in z index map");
                    }
                    ZStructVector zStructVector = category.zStructVector();
                    if (!vectorEnumerators.containsKey(zStructVector)) {
                        vectorEnumerators.put(zStructVector, new Enumerator());
                    }
                }
                for (FVariable var : vars) {
                    ZCategory category = var.zCategory();
                    if (category == null) {
                        // Ignore, not supposed to be in any index map!
                        continue;
                    }
                    Collection<FVariable> catVars = varMap.get(category);
                    if (catVars == null) {
                        // Ignore, not of interest in this index map!
                        continue;
                    }
                    catVars.add(var);
                }
                categoryMap = new LinkedHashMap<ZCategory, ZCategoryEntry>(zIndexOrder.length);
                String prevZOffsetName = null;
                for (ZCategory category : zIndexOrder) {
                    java.util.List<FVariable> categoryVars = varMap.get(category);
                    Comparator<FVariable> sorter = category.sorter(categoryVars, fclass);
                    if (sorter != null) {
                        Collections.sort(categoryVars, sorter);
                    }
                    Enumerator enumerator = vectorEnumerators.get(category.zStructVector());
                    String zOffsetName = category.zOffsetName();
                    ZCategoryEntry entry = category.createEntry(
                            categoryVars, enumerator, zOffsetMap.get(zOffsetName));
                    categoryMap.put(category, entry);
                    if (!zOffsetMap.containsKey(zOffsetName)) {
                        zOffsetMap.put(zOffsetName, entry.offset());
                    } else if (!zOffsetName.equals(prevZOffsetName)) {
                        throw new IllegalArgumentException(
                                "Z offset category '" + zOffsetName + "' is not continuous in z index map.");
                    }
                    prevZOffsetName = zOffsetName;
                }
            }

            /**
             * Used for filtering on specific categories
             */
            public static abstract class CategoryFilter implements Criteria<Map.Entry<ZCategory, ZCategoryEntry>> {
                @Override
                public boolean test(Entry<ZCategory, ZCategoryEntry> elem) {
                    if (elem.getKey() instanceof ZOrdinaryCategory) {
                        return test((ZOrdinaryCategory) elem.getKey());
                    } else {
                        return false;
                    }
                }

                /**
                 * Null safe version of test(ZOrdinaryCategory). E.g. if null
                 * is given, then false is returned.
                 */
                public boolean testSingle(ZOrdinaryCategory category) {
                    return category != null && test(category);
                }

                protected abstract boolean test(ZOrdinaryCategory category);
            }

            /**
             * Provides a collection containing all variables with specified
             * type. This collection is read only and only support a small
             * number of operations that collection supports.
             */
            public Collection<FVariable> getBy(final ZType type) {
                return getBy(new CategoryFilter() {
                    @Override
                    protected boolean test(ZOrdinaryCategory category) {
                        return category.type == type;
                    }
                });
            }

            /**
             * Provides a collection containing all variables with specified
             * variability. This collection is read only and only support a
             * small number of operations that collection supports.
             */
            public Collection<FVariable> getBy(final ZVariability variability) {
                return getBy(new CategoryFilter() {
                    @Override
                    protected boolean test(ZOrdinaryCategory category) {
                        return category.variability == variability;
                    }
                    
                });
            }

            /**
             * Provides a collection containing all variables with specified
             * dependency and variability. This collection is read only and 
             * only support a small number of operations that collection supports.
             */
            public Collection<FVariable> getBy(final ParaDependency dependency, final ZVariability variability) {
                return getBy(new CategoryFilter() {
                    @Override
                    protected boolean test(ZOrdinaryCategory category) {
                        return category.dependency == dependency && category.variability == variability;
                    }
                    
                });
            }

            private static final CategoryFilter PARAMETER_FILTER = new CategoryFilter() {
                @Override
                public boolean test(ZOrdinaryCategory category) {
                    return category.variability.isParameter();
                }
                
            };

            /**
             * Provides a collection containing all parameters with specified
             * dependency. This collection is read only and only support a
             * small number of operations that collection supports.
             */
            public Collection<FVariable> getParameterBy(final ParaDependency dependency) {
                return getBy(new CategoryFilter() {
                    @Override
                    protected boolean test(ZOrdinaryCategory category) {
                        return category.dependency == dependency && PARAMETER_FILTER.test(category);
                    }
                    
                });
            }

            /**
             * Provides a collection containing all parameters with specified
             * dependency and type. This collection is read only and only
             * support a small number of operations that collection supports.
             */
            public Collection<FVariable> getParameterBy(final ParaDependency dependency, final ZType type) {
                return getBy(new CategoryFilter() {
                    @Override
                    protected boolean test(ZOrdinaryCategory category) {
                        return category.dependency == dependency && category.type == type && PARAMETER_FILTER.test(category);
                    }
                    
                });
            }

            public Collection<FVariable> getBy(CategoryFilter filter) {
                return new SelectiveCollection(filter);
            }

            public ZCategoryEntry getBy(ZCategory category) {
                return categoryMap.get(category);
            }

            /**
             * Visit all variables in z-order, using provided visitor.
             * If pre is true, then visit only those categories that have pre versions.
             */
            public void visitZOrder(ZVisitor v, boolean pre) {
                for (ZCategory category : (pre ? zIndexOrderPre : zIndexOrder)) {
                    getBy(category).visitZOrder(v);
                }
            }

            @Override
            public String toString() {
                StringBuilder sb = new StringBuilder();
                for (Map.Entry<ZCategory, ZCategoryEntry> entry : categoryMap.entrySet()) {
                    if (entry.getValue().size > 0) {
                        sb.append(entry.getKey());
                        sb.append(" (");
                        sb.append(entry.getValue().size);
                        sb.append(" scalars, ");
                        sb.append(entry.getValue().indexMap.size());
                        sb.append(" entries):\n");
                        for (Map.Entry<FVariable, Integer> varEntry : entry.getValue().indexMap.entrySet()) {
                            sb.append("  ");
                            sb.append(varEntry.getValue());
                            sb.append(": ");
                            sb.append(varEntry.getKey().name());
                            sb.append("\n");
                        }
                    }
                }
                return sb.toString();
            }

            /**
             * Class which is returned when selecting a sub-set of the
             * categories.
             */
            private class SelectiveCollection implements Collection<FVariable> {
                private final Iterable<Map.Entry<ZCategory, ZCategoryEntry>> entries;

                private SelectiveCollection(CategoryFilter filter) {
                    entries = new FilteredIterable<Map.Entry<ZCategory, ZCategoryEntry>>(categoryMap.entrySet(), filter);
                }

                public int size() {
                    int size = 0;
                    for (Map.Entry<ZCategory, ZCategoryEntry> entry : entries) {
                        size += entry.getValue().size;
                    }
                    return size;
                }

                @Override
                public Iterator<FVariable> iterator() {
                    return new Iterator<FVariable>() {

                        private Iterator<FVariable> current;
                        private Iterator<Map.Entry<ZCategory, ZCategoryEntry>> entryIter = entries.iterator();

                        @Override
                        public boolean hasNext() {
                            while ((current == null || !current.hasNext()) && entryIter.hasNext()) {
                                current = entryIter.next().getValue().iterator();
                            }
                            return current.hasNext();
                        }

                        @Override
                        public FVariable next() {
                            if (!hasNext()) {
                                throw new NoSuchElementException();
                            }
                            return current.next();
                        }

                        @Override
                        public void remove() {
                            throw new UnsupportedOperationException();
                        }
                    };
                }

                @Override
                public boolean add(FVariable arg0) {
                    throw new UnsupportedOperationException();
                }

                @Override
                public boolean addAll(Collection<? extends FVariable> c) {
                    throw new UnsupportedOperationException();
                }

                @Override
                public void clear() {
                    throw new UnsupportedOperationException();
                }

                @Override
                public boolean contains(Object o) {
                    throw new UnsupportedOperationException("Don't use, inefficient!");
                }

                @Override
                public boolean containsAll(Collection<?> c) {
                    throw new UnsupportedOperationException("Don't use, inefficient!");
                }

                @Override
                public boolean isEmpty() {
                    return size() == 0;
                }

                @Override
                public boolean remove(Object o) {
                    throw new UnsupportedOperationException();
                }

                @Override
                public boolean removeAll(Collection<?> c) {
                    throw new UnsupportedOperationException();
                }

                @Override
                public boolean retainAll(Collection<?> c) {
                    throw new UnsupportedOperationException();
                }

                @Override
                public Object[] toArray() {
                    throw new UnsupportedOperationException();
                }

                @Override
                public <T> T[] toArray(T[] a) {
                    throw new UnsupportedOperationException();
                }
            }
        }

        /**
         * Represents an entry of ZCategory and contains the offset, size and
         * variables which falls into the specified category.
         * 
         * This class only implements a sub-set of the collection interface.
         */
        public static class ZCategoryEntry implements Collection<FVariable> {
            private final int offset;
            private final int groupOffset;
            private final int size;
            private final Map<FVariable, Integer> indexMap;
            private final ZCategory category;

            public ZCategoryEntry(ZCategory category, int size, Enumerator enumerator, Integer groupOffset) {
                this.category = category;
                this.offset = enumerator.peek();
                this.groupOffset = (groupOffset == null) ? this.offset : groupOffset;
                this.size = size;
                this.indexMap = Collections.emptyMap();
                // Now wind forward the enumerator
                for (int i = 0; i < size; i++, enumerator.next());
            }

            public ZCategoryEntry(ZCategory category, Collection<FVariable> vars, Enumerator enumerator, Integer groupOffset) {
                this.category = category;
                this.offset = enumerator.peek();
                this.groupOffset = (groupOffset == null) ? this.offset : groupOffset;
                Map<FVariable, Integer> indexMap = new LinkedHashMap<FVariable, Integer>(vars.size());
                for (FVariable var : vars) {
                    indexMap.put(var, var.incrementValueReferenceIndex(enumerator));
                }
                size = enumerator.peek() - this.offset;
                this.indexMap = Collections.unmodifiableMap(indexMap);
            }

            public int getIndexFor(FVariable var) {
                return indexMap.get(var);
            }

            public int getOffsetIndexFor(FVariable var) {
                return indexMap.get(var) - groupOffset;
            }

            public int getValueReferenceFor(FVariable var) {
                return category.valueReferenceFromIndex(getIndexFor(var));
            }

            public int offset() {
                return offset;
            }

            public ZCategory category() {
                return category;
            }

            public void visitZOrder(ZVisitor v) {
                category.visitZOrder(v);
                for (FVariable fv : this) {
                    v.visitVariable(fv, this);
                }
            }

            @Override
            public Iterator<FVariable> iterator() {
                return indexMap.keySet().iterator();
            }

            @Override
            public boolean add(FVariable e) {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean addAll(Collection<? extends FVariable> c) {
                throw new UnsupportedOperationException();
            }

            @Override
            public void clear() {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean contains(Object o) {
                throw new UnsupportedOperationException("Don't use, inefficient!");
            }

            @Override
            public boolean containsAll(Collection<?> c) {
                throw new UnsupportedOperationException("Don't use, inefficient!");
            }

            @Override
            public boolean isEmpty() {
                return size() == 0;
            }

            @Override
            public boolean remove(Object o) {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean removeAll(Collection<?> c) {
                throw new UnsupportedOperationException();
            }

            @Override
            public boolean retainAll(Collection<?> c) {
                throw new UnsupportedOperationException();
            }

            @Override
            public int size() {
                return size;
            }

            @Override
            public Object[] toArray() {
                throw new UnsupportedOperationException();
            }

            @Override
            public <T> T[] toArray(T[] a) {
                throw new UnsupportedOperationException();
            }
        }
    }

    /**
     * Returns the z variability enum for this variability and supplied
     * variable.
     */
    public FClass.ZVariability TypePrefixVariability.zVariability(FVariable var) {
        return null;
    }
    public FClass.ZVariability Constant.zVariability(FVariable var) {
        return FClass.ZVariability.CONSTANT;
    }
    public FClass.ZVariability FixedParameter.zVariability(FVariable var) {
        return FClass.ZVariability.REGULAR_PARAMETER;
    }
    public FClass.ZVariability StructParameter.zVariability(FVariable var) {
        return FClass.ZVariability.STRUCTURAL_PARAMETER;
    }
    public FClass.ZVariability FinalParameter.zVariability(FVariable var) {
        return FClass.ZVariability.FINAL_PARAMETER;
    }
    public FClass.ZVariability EvalTrueParameter.zVariability(FVariable var) {
        return FClass.ZVariability.EVAL_PARAMETER;
    }
    public FClass.ZVariability InitialParameter.zVariability(FVariable var) {
        return FClass.ZVariability.INITIAL_PARAMETER;
    }
    public FClass.ZVariability Discrete.zVariability(FVariable var) {
        if (var.isInput()) {
            return FClass.ZVariability.INPUT;
        } else {
            return FClass.ZVariability.DISCRETE;
        }
    }
    public FClass.ZVariability Continuous.zVariability(FVariable var) {
        if (var.isInput()) {
            return FClass.ZVariability.INPUT;
        } else if (var.differentiatedByFDerExp()) {
            return FClass.ZVariability.DIFFERENTIATED;
        } else if (var.isDerivativeVariable()) {
            return FClass.ZVariability.DERIVATIVE;
        } else {
            return FClass.ZVariability.CONTINUOUS;
        }
    }

    /**
     * Util for finding all differentiated variables. Can't use the fact that
     * for var x there is a variable der(x), not true before additon of
     * derivative variables!
     */
    coll LinkedHashSet<FVariable> FClass.differentiatedByFDerExp() 
        [new LinkedHashSet<FVariable>()] with add root FClass;
    FDerExp contributes getFAccess().myFV().asFVariable() when getFAccess().myFV().isFVariable() && !inDeadIfBranch()
        to FClass.differentiatedByFDerExp() for myFClass();
    FDerivativeVariable contributes myDifferentiatedVariable().asFVariable() when (shouldContribute())
        to FClass.differentiatedByFDerExp() for myFClass();

    syn boolean FVariable.differentiatedByFDerExp() = myFClass().differentiatedByFDerExp().contains(this);

    /**
     * Calculates the z variability enum for this variable.
     */
    syn FClass.ZVariability FVariable.zVariability() = getTypePrefixVariability().zVariability(this);

    syn FClass.ZType FType.genType() = null;
    eq FBooleanType.genType()          = FClass.ZType.BOOLEAN;
    eq FEnumLiteralType.genType()      = FClass.ZType.ENUM;
    eq FEnumType.genType()             = FClass.ZType.ENUM;
    eq FIntegerType.genType()          = FClass.ZType.INTEGER;
    eq FRealType.genType()             = FClass.ZType.REAL;
    eq FStringType.genType()           = FClass.ZType.STRING;
    eq FExternalObjectType.genType()   = FClass.ZType.EXTERNAL;

    /**
     * Lazy attribute which holds the variable reference map.
     */
    syn lazy VarRefMap FClass.varRefMap() = new VarRefMap(getFVariables(), this);

    syn FClass.ZOrdinaryCategory FVariable.zCategory() = FClass.ZOrdinaryCategory.resolve(this);

    public int FVariable.incrementValueReferenceIndex(Enumerator e) {
        return e.next();
    }

    /**
     * The value reference value is represented by a 32 bit unsigned integer 
     * variable. The lowest 27 bits is used to represent the index of a 
     * variable of the corresponding variable vector. Real, Integer, Boolean and 
     * enumeration variables share a vector, while String variables has their 
     * own vector. 
     * Bit 28 is reserved for representing negated/not negated.
     * Bits 29-31 represents the primitive type, where:
     * 0: Real
     * 1: Integer or enumeration
     * 2: Boolean
     * 3: String
     * Bit 32 is left unused.
     *
     */
    inh lazy int FAbstractVariable.valueReference();
    eq FClass.getFVariable(int i).valueReference() {
        FVariable var = getFVariable(i);
        ZOrdinaryCategory category = ZOrdinaryCategory.resolve(var);
        if (category == null) {
            return -1;
        }
        return category.type.mask(varRefMap().getBy(category).getIndexFor(var));
    }
    eq FClass.getAliasVariable(int i).valueReference() = getAliasVariable(i).aliasValueReference();
    eq FClass.getFAbstractEquation().valueReference()  = -1;
    eq Root.getChild().valueReference()                = -1;
    
    syn int FVariable.aliasValueReference() = alias() != null ? alias().valueReference() : -1;

    syn int FAbstractVariable.indexInZ() = -1;
    eq FVariable.indexInZ() = valueReference() & 0x07FFFFFF;

    syn boolean FAccessExp.isConsecutiveInZ(FAccessExp use) = myFV().isConsecutiveInZ(use.myFV());

    syn boolean FAbstractVariable.isConsecutiveInZ(FAbstractVariable fv) = false;
    eq FVariable.isConsecutiveInZ(FAbstractVariable fv) = indexInZ() + 1 == fv.indexInZ();

    
    syn int FClass.derivativeVariablesOffset() = varRefMap().getBy(ZOrdinaryCategory.DERIVATIVE).offset();
    syn int FClass.realInputsOffset() = varRefMap().getBy(ZOrdinaryCategory.REAL_INPUT).offset();
    syn int FClass.algebraicContinousRealVariablesOffset() = varRefMap().getBy(ZOrdinaryCategory.CONTINUOUS).offset();


    syn int FClass.integerInputsOffset() = varRefMap().getBy(ZOrdinaryCategory.INTEGER_INPUT).offset();
    syn int FClass.enumInputsOffset() = varRefMap().getBy(ZOrdinaryCategory.ENUM_INPUT).offset();

    syn int FClass.booleanInputsOffset() = varRefMap().getBy(ZOrdinaryCategory.BOOLEAN_INPUT).offset();

    syn int FClass.timeOffset() = varRefMap().getBy(ZCategory.TIME).offset();

    syn int FClass.homotopyLambdaOffset() = varRefMap().getBy(ZCategory.HOMOTOPY_LAMBDA).offset();

    // TODO: Remove!?
    syn boolean FVariable.shouldContribute() = !isAlias() && !inRecord() && !isForIndex();
    
    // TODO: Remove?!?
    syn boolean FDerivativeVariable.shouldContributeFiltered() = shouldContribute() && (myDifferentiatedVariable().asFVariable().stateSelectAttributeSet() || uses().size() > 0);
    
    public class FClass {
        public static <T1, T2 extends T1> Collection<T2> filterCollection(Collection<T1> input, Criteria<T1> filter) {
            Collection<T2> res = new ArrayList<T2>();
            for (T1 elm : input) {
                if (filter.test(elm))
                    res.add((T2)elm);
            }
            return res;
        }
        
        // TODO: Remove?!
        public static <T extends FVariable, C extends Set<T>> C intersectFVSet(
                C a, Collection<? extends FVariable> b) {
            try {
                // To avoid having to have different versions for different collections
                C res = (C) a.getClass().newInstance();
                res.addAll(a);
                res.retainAll(b);
                return res;
            } catch (IllegalAccessException e) {
            } catch (InstantiationException e) {
            }
            throw new IllegalArgumentException("First argument must be of class with public default constructor.");
        }
        
        public static final Criteria<FVariable> REAL_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isReal();
            }
        };
        
        public static final Criteria<FVariable> INTEGER_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isInteger();
            }
        };
        
        public static final Criteria<FVariable> BOOLEAN_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isBoolean();
            }
        };
        
        public static final Criteria<FVariable> STRING_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isString();
            }
        };
        
        public static final Criteria<FVariable> ENUM_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isEnum();
            }
        };
        
    }






    syn int FClass.numReals() = reals().size();
    syn Collection<FVariable> FClass.reals() = varRefMap().getBy(ZType.REAL);

    syn int FClass.numIntegers() = integers().size();
    syn Collection<FVariable> FClass.integers() = varRefMap().getBy(ZType.INTEGER);

    syn int FClass.numEnums() = enums().size();
    syn Collection<FVariable> FClass.enums() = varRefMap().getBy(ZType.ENUM);

    syn int FClass.numBooleans() = booleans().size();
    syn Collection<FVariable> FClass.booleans() = varRefMap().getBy(ZType.BOOLEAN);

    syn int FClass.numStrings() = strings().size();
    syn Collection<FVariable> FClass.strings() = varRefMap().getBy(ZType.STRING);

    syn int FClass.numIndependentConstants() = independentConstants().size();
    syn Collection<FVariable> FClass.independentConstants() = varRefMap().getBy(ParaDependency.INDEPENDENT, ZVariability.CONSTANT);

    syn int FClass.numExternalObjectVariables() = externalObjectVariables().size();
    syn Collection<FVariable> FClass.externalObjectVariables() = varRefMap().getBy(ZType.EXTERNAL);

    syn int FClass.independentRealConstantsOffset() = independentRealConstants().offset();
    syn int FClass.numIndependentRealConstants() = independentRealConstants().size();
    syn ZCategoryEntry FClass.independentRealConstants() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_REAL_CONSTANT);

    syn int FClass.independentIntegerConstantsOffset() = independentIntegerConstants().offset();
    syn int FClass.numIndependentIntegerConstants() = independentIntegerConstants().size();
    syn ZCategoryEntry FClass.independentIntegerConstants() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_INTEGER_CONSTANT);

    syn int FClass.independentEnumConstantsOffset() = independentEnumConstants().offset();
    syn int FClass.numIndependentEnumConstants() = independentEnumConstants().size();
    syn ZCategoryEntry FClass.independentEnumConstants() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_ENUM_CONSTANT);

    syn int FClass.independentBooleanConstantsOffset() = independentBooleanConstants().offset();
    syn int FClass.numIndependentBooleanConstants() = independentBooleanConstants().size();
    syn ZCategoryEntry FClass.independentBooleanConstants() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_BOOLEAN_CONSTANT);
    
    syn int FClass.numIndependentStringConstants() = independentStringConstants().size();
    syn ZCategoryEntry FClass.independentStringConstants() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_STRING_CONSTANT);

    // TODO: Is there such a thing as a dependent constant??
    syn int FClass.numDependentConstants() = dependentConstants().size();
    syn Collection<FVariable> FClass.dependentConstants() = varRefMap().getBy(ParaDependency.DEPENDENT, ZVariability.CONSTANT);

    syn int FClass.dependentRealConstantsOffset() = dependentRealConstants().offset();
    syn int FClass.numDependentRealConstants() = dependentRealConstants().size();
    syn ZCategoryEntry FClass.dependentRealConstants() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_REAL_CONSTANT);

    syn int FClass.dependentIntegerConstantsOffset() = dependentIntegerConstants().offset();
    syn int FClass.numDependentIntegerConstants() = dependentIntegerConstants().size();
    syn ZCategoryEntry FClass.dependentIntegerConstants() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_INTEGER_CONSTANT);

    syn int FClass.dependentEnumConstantsOffset() = dependentEnumConstants().offset();
    syn int FClass.numDependentEnumConstants() = dependentEnumConstants().size();
    syn ZCategoryEntry FClass.dependentEnumConstants() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_ENUM_CONSTANT);

    syn int FClass.dependentBooleanConstantsOffset() = dependentBooleanConstants().offset();
    syn int FClass.numDependentBooleanConstants() = dependentBooleanConstants().size();
    syn ZCategoryEntry FClass.dependentBooleanConstants() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_BOOLEAN_CONSTANT);

    syn int FClass.numDependentStringConstants() = dependentStringConstants().size();
    syn ZCategoryEntry FClass.dependentStringConstants() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_STRING_CONSTANT);

    syn int FClass.numIndependentParameters() = independentParameters().size();
    syn Collection<FVariable> FClass.independentParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT);
    
    syn int FClass.numIndependentRealParameters() = independentRealParameters().size();
    syn Collection<FVariable> FClass.independentRealParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT, ZType.REAL);
    
    syn int FClass.numIndependentIntegerParameters() = independentIntegerParameters().size();
    syn Collection<FVariable> FClass.independentIntegerParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT, ZType.INTEGER);
    
    syn int FClass.numIndependentEnumParameters() = independentEnumParameters().size();
    syn Collection<FVariable> FClass.independentEnumParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT, ZType.ENUM);
    
    syn int FClass.numIndependentBooleanParameters() = independentBooleanParameters().size();
    syn Collection<FVariable> FClass.independentBooleanParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT, ZType.BOOLEAN);
    
    syn int FClass.numIndependentStringParameters() = independentStringParameters().size();
    syn Collection<FVariable> FClass.independentStringParameters() = varRefMap().getParameterBy(ParaDependency.INDEPENDENT, ZType.STRING);
    
    syn int FClass.numRegularIndependentParameters() = regularIndependentParameters().size();
    syn Collection<FVariable> FClass.regularIndependentParameters() = varRefMap().getBy(ParaDependency.INDEPENDENT, ZVariability.REGULAR_PARAMETER);
    
    syn int FClass.independentRealParametersOffset() = regularIndependentRealParameters().offset();
    syn int FClass.numRegularIndependentRealParameters() = regularIndependentRealParameters().size();
    syn ZCategoryEntry FClass.regularIndependentRealParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_REAL_REGULAR_PARAMETER);

    syn int FClass.independentIntegerParametersOffset() = regularIndependentIntegerParameters().offset();
    syn int FClass.numRegularIndependentIntegerParameters() = regularIndependentIntegerParameters().size();
    syn ZCategoryEntry FClass.regularIndependentIntegerParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_INTEGER_REGULAR_PARAMETER);

    syn int FClass.independentEnumParametersOffset() = regularIndependentEnumParameters().offset();
    syn int FClass.numRegularIndependentEnumParameters() = regularIndependentEnumParameters().size();
    syn ZCategoryEntry FClass.regularIndependentEnumParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_ENUM_REGULAR_PARAMETER);
    
    syn int FClass.independentBooleanParametersOffset() = regularIndependentBooleanParameters().offset();
    syn int FClass.numRegularIndependentBooleanParameters() = regularIndependentBooleanParameters().size();
    syn ZCategoryEntry FClass.regularIndependentBooleanParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_BOOLEAN_REGULAR_PARAMETER);

    syn int FClass.numRegularIndependentStringParameters() = regularIndependentStringParameters().size();
    syn ZCategoryEntry FClass.regularIndependentStringParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_STRING_REGULAR_PARAMETER);
    
    syn int FClass.numStructuralIndependentParameters() = structuralIndependentParameters().size();
    syn Collection<FVariable> FClass.structuralIndependentParameters() = varRefMap().getBy(ParaDependency.INDEPENDENT, ZVariability.STRUCTURAL_PARAMETER);
    
    syn int FClass.numStructuralIndependentRealParameters() = structuralIndependentRealParameters().size();
    syn ZCategoryEntry FClass.structuralIndependentRealParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_REAL_STRUCTURAL_PARAMETER);
    
    syn int FClass.numStructuralIndependentIntegerParameters() = structuralIndependentIntegerParameters().size();
    syn ZCategoryEntry FClass.structuralIndependentIntegerParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_INTEGER_STRUCTURAL_PARAMETER);
    
    syn int FClass.numStructuralIndependentEnumParameters() = structuralIndependentEnumParameters().size();
    syn ZCategoryEntry FClass.structuralIndependentEnumParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_ENUM_STRUCTURAL_PARAMETER);
    
    syn int FClass.numStructuralIndependentBooleanParameters() = structuralIndependentBooleanParameters().size();
    syn ZCategoryEntry FClass.structuralIndependentBooleanParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_BOOLEAN_STRUCTURAL_PARAMETER);
    
    syn int FClass.numStructuralIndependentStringParameters() = structuralIndependentStringParameters().size();
    syn ZCategoryEntry FClass.structuralIndependentStringParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_STRING_STRUCTURAL_PARAMETER);
    
    syn int FClass.numFinalIndependentParameters() = finalIndependentParameters().size();
    syn Collection<FVariable> FClass.finalIndependentParameters() = varRefMap().getBy(ParaDependency.INDEPENDENT, ZVariability.FINAL_PARAMETER);
    
    syn int FClass.numFinalIndependentRealParameters() = finalIndependentRealParameters().size();
    syn ZCategoryEntry FClass.finalIndependentRealParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_REAL_FINAL_PARAMETER);
    
    syn int FClass.numFinalIndependentIntegerParameters() = finalIndependentIntegerParameters().size();
    syn ZCategoryEntry FClass.finalIndependentIntegerParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_INTEGER_FINAL_PARAMETER);
    
    syn int FClass.numFinalIndependentEnumParameters() = finalIndependentEnumParameters().size();
    syn ZCategoryEntry FClass.finalIndependentEnumParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_ENUM_FINAL_PARAMETER);
    
    syn int FClass.numFinalIndependentBooleanParameters() = finalIndependentBooleanParameters().size();
    syn ZCategoryEntry FClass.finalIndependentBooleanParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_BOOLEAN_FINAL_PARAMETER);
    
    syn int FClass.numFinalIndependentStringParameters() = finalIndependentStringParameters().size();
    syn ZCategoryEntry FClass.finalIndependentStringParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_STRING_FINAL_PARAMETER);
    
    syn int FClass.numEvalIndependentParameters() = evalIndependentParameters().size();
    syn Collection<FVariable> FClass.evalIndependentParameters() = varRefMap().getBy(ParaDependency.INDEPENDENT, ZVariability.STRUCTURAL_PARAMETER);
    
    syn int FClass.numEvalIndependentRealParameters() = evalIndependentRealParameters().size();
    syn ZCategoryEntry FClass.evalIndependentRealParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_REAL_EVAL_PARAMETER);
    
    syn int FClass.numEvalIndependentIntegerParameters() = evalIndependentIntegerParameters().size();
    syn ZCategoryEntry FClass.evalIndependentIntegerParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_INTEGER_EVAL_PARAMETER);
    
    syn int FClass.numEvalIndependentEnumParameters() = evalIndependentEnumParameters().size();
    syn ZCategoryEntry FClass.evalIndependentEnumParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_ENUM_EVAL_PARAMETER);
    
    syn int FClass.numEvalIndependentBooleanParameters() = evalIndependentBooleanParameters().size();
    syn ZCategoryEntry FClass.evalIndependentBooleanParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_BOOLEAN_EVAL_PARAMETER);
    
    syn int FClass.numEvalIndependentStringParameters() = evalIndependentStringParameters().size();
    syn ZCategoryEntry FClass.evalIndependentStringParameters() = varRefMap().getBy(ZOrdinaryCategory.INDEPENDENT_STRING_EVAL_PARAMETER);
    
    syn int FClass.numDependentParameters() = dependentParameters().size();
    syn Collection<FVariable> FClass.dependentParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT);

    syn int FClass.numDependentRealParameters() = dependentRealParameters().size();
    syn Collection<FVariable> FClass.dependentRealParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT, ZType.REAL);

    syn int FClass.numDependentIntegerParameters() = dependentIntegerParameters().size();
    syn Collection<FVariable> FClass.dependentIntegerParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT, ZType.INTEGER);

    syn int FClass.numDependentEnumParameters() = dependentEnumParameters().size();
    syn Collection<FVariable> FClass.dependentEnumParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT, ZType.ENUM);

    syn int FClass.numDependentBooleanParameters() = dependentBooleanParameters().size();
    syn Collection<FVariable> FClass.dependentBooleanParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT, ZType.BOOLEAN);
    
    syn int FClass.numDependentStringParameters() = dependentStringParameters().size();
    syn Collection<FVariable> FClass.dependentStringParameters() = varRefMap().getParameterBy(ParaDependency.DEPENDENT, ZType.STRING);
    
    syn int FClass.dependentRealRegularParametersOffset() = dependentRealRegularParameters().offset();
    syn int FClass.numDependentRealRegularParameters() = dependentRealRegularParameters().size();
    syn ZCategoryEntry FClass.dependentRealRegularParameters() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_REAL_REGULAR_PARAMETER);

    syn int FClass.dependentIntegerRegularParametersOffset() = dependentIntegerRegularParameters().offset();
    syn int FClass.numDependentIntegerRegularParameters() = dependentIntegerRegularParameters().size();
    syn ZCategoryEntry FClass.dependentIntegerRegularParameters() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_INTEGER_REGULAR_PARAMETER);

    syn int FClass.dependentEnumRegularParametersOffset() = dependentEnumRegularParameters().offset();
    syn int FClass.numDependentEnumRegularParameters() = dependentEnumRegularParameters().size();
    syn ZCategoryEntry FClass.dependentEnumRegularParameters() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_ENUM_REGULAR_PARAMETER);
    
    syn int FClass.dependentBooleanRegularParametersOffset() = dependentBooleanRegularParameters().offset();
    syn int FClass.numDependentBooleanRegularParameters() = dependentBooleanRegularParameters().size();
    syn ZCategoryEntry FClass.dependentBooleanRegularParameters() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_BOOLEAN_REGULAR_PARAMETER);
    
    syn int FClass.numDependentStringRegularParameters() = dependentStringRegularParameters().size();
    syn ZCategoryEntry FClass.dependentStringRegularParameters() = varRefMap().getBy(ZOrdinaryCategory.DEPENDENT_STRING_REGULAR_PARAMETER);
    
    syn int FClass.realInitialParametersOffset() = realInitialParameters().offset();
    syn int FClass.numRealInitialParameters() = realInitialParameters().size();
    syn ZCategoryEntry FClass.realInitialParameters() = varRefMap().getBy(ZOrdinaryCategory.REAL_INITIAL_PARAMETER);
    
    syn int FClass.integerInitialParametersOffset() = integerInitialParameters().offset();
    syn int FClass.numIntegerInitialParameters() = integerInitialParameters().size();
    syn ZCategoryEntry FClass.integerInitialParameters() = varRefMap().getBy(ZOrdinaryCategory.INTEGER_INITIAL_PARAMETER);
    
    syn int FClass.enumInitialParametersOffset() = enumInitialParameters().offset();
    syn int FClass.numEnumInitialParameters() = enumInitialParameters().size();
    syn ZCategoryEntry FClass.enumInitialParameters() = varRefMap().getBy(ZOrdinaryCategory.ENUM_INITIAL_PARAMETER);
    
    syn int FClass.booleanInitialParametersOffset() = booleanInitialParameters().offset();
    syn int FClass.numBooleanInitialParameters() = booleanInitialParameters().size();
    syn ZCategoryEntry FClass.booleanInitialParameters() = varRefMap().getBy(ZOrdinaryCategory.BOOLEAN_INITIAL_PARAMETER);
    
    syn int FClass.numStringInitialParameters() = stringInitialParameters().size();
    syn ZCategoryEntry FClass.stringInitialParameters() = varRefMap().getBy(ZOrdinaryCategory.STRING_INITIAL_PARAMETER);

    /**
     * Optimica specific but used in Modelica...
     */
    syn int FClass.numFreeParameters() = freeParameters().size();
    syn Collection<FVariable> FClass.freeParameters() = varRefMap().getBy(ZVariability.FREE_PARAMETER);


    syn int FClass.discreteRealVariablesOffset() = discreteRealVariables().offset();
    syn int FClass.numDiscreteRealVariables() = discreteRealVariables().size();
    syn ZCategoryEntry FClass.discreteRealVariables() = varRefMap().getBy(ZOrdinaryCategory.DISCRETE_REAL);

    syn int FClass.discreteIntegerVariablesOffset() = discreteIntegerVariables().offset();
    syn int FClass.numDiscreteIntegerVariables() = discreteIntegerVariables().size();
    syn ZCategoryEntry FClass.discreteIntegerVariables() = varRefMap().getBy(ZOrdinaryCategory.DISCRETE_INTEGER);

    syn int FClass.discreteEnumVariablesOffset() = discreteEnumVariables().offset();
    syn int FClass.numDiscreteEnumVariables() = discreteEnumVariables().size();
    syn ZCategoryEntry FClass.discreteEnumVariables() = varRefMap().getBy(ZOrdinaryCategory.DISCRETE_ENUM);

    syn int FClass.discreteBooleanVariablesOffset() = discreteBooleanVariables().offset();
    syn int FClass.numDiscreteBooleanVariables() = discreteBooleanVariables().size();
    syn ZCategoryEntry FClass.discreteBooleanVariables() = varRefMap().getBy(ZOrdinaryCategory.DISCRETE_BOOLEAN);

    syn int FClass.numDiscreteStringVariables() = discreteStringVariables().size();
    syn ZCategoryEntry FClass.discreteStringVariables() = varRefMap().getBy(ZOrdinaryCategory.DISCRETE_STRING);

    syn int FClass.differentiatedRealVariablesOffset() = differentiatedRealVariables().offset();
    syn int FClass.numDifferentiatedRealVariables() = differentiatedRealVariables().size();
    syn ZCategoryEntry FClass.differentiatedRealVariables() = varRefMap().getBy(ZOrdinaryCategory.DIFFERENTIATED);

    // TODO: This should be removed!
    syn lazy ArrayList<FVariable> FClass.differentiatedRealVariablesList() {
        ArrayList<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : differentiatedRealVariables()) 
            l.add(fv);
        return l;
    }
    syn int FVariable.differentiatedRealVariableIndex() =
        myFClass().differentiatedRealVariablesList().indexOf(this);

    syn lazy LinkedHashSet<FVariable> FClass.allDifferentiatedRealVariables() {
        LinkedHashSet<FVariable> set = new LinkedHashSet<FVariable>();
        set.addAll(differentiatedRealVariables());
        set.addAll(dynamicStates());
        return set;
    }

    /**
     * Collection that contains all differentiated variables that has been
     * found to be dynamic states. All of these variables originates from
     * the original model.
     */
    coll LinkedHashSet<FRealVariable> FClass.dynamicStates()
      [new LinkedHashSet<FRealVariable>()] with add root FClass;
    FRealVariable contributes this when (isDynamicState())
      to FClass.dynamicStates() for myFClass();
    syn int FClass.numDynamicStates() = dynamicStates().size();

    /**
     * Collection that contains all dynamic state variables introduced by the
     * compiler. This collection differs from dynamicStates() in that it 
     * contains all the actual states.
     */
    coll LinkedHashSet<FDynamicStateVariable> FClass.dynamicStateVariables()
      [new LinkedHashSet<FDynamicStateVariable>()] with add root FClass;
    FDynamicStateVariable contributes this 
      to FClass.dynamicStateVariables() for myFClass();
    syn int FClass.numDynamicStateVariables() = dynamicStateVariables().size();

    /**
     * Collection that contains all dynamic algebraic variables introduced by the
     * compiler.
     */
    coll LinkedHashSet<FDynamicAlgebraicVariable> FClass.dynamicAlgebraicVariables()
    [new LinkedHashSet<FDynamicAlgebraicVariable>()] with add root FClass;
      FDynamicAlgebraicVariable contributes this 
    to FClass.dynamicAlgebraicVariables() for myFClass();
    syn int FClass.numDynamicAlgebraicVariables() = dynamicAlgebraicVariables().size();

    /**
     * Returns the same set as differentiatedRealVariablesSet, except derivatives with no
     * uses that were not introduced because of stateselect.
     */
    coll LinkedHashSet<FRealVariable> FClass.differentiatedRealVariablesFilteredSet() 
      [new LinkedHashSet<FRealVariable>()] with add root FClass;
    FDerExp contributes (FRealVariable) getFAccess().myFV() when getFAccess().myFV().isFVariable() && !inDeadIfBranch()
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    FDerivativeVariable contributes
        myDifferentiatedVariable().asFRealVariable() when (shouldContributeFiltered())
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    FDynamicStateVariable contributes this
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    
    /**
     * \brief Collection of all callables called by a partial function call
     * or kept as a component.
     */
    coll LinkedHashSet<FFunctionDecl> FClass.myFFunctionDeclsPartial() 
        [new LinkedHashSet<FFunctionDecl>()] with add root FClass;
    FPartialFunctionCall contributes myFCallable().actualFFunctionDecl() to FClass.myFFunctionDeclsPartial() for myFClass();
    FFunctionVariable contributes myFCallable().actualFFunctionDecl() when type().isFunction()
        to FClass.myFFunctionDeclsPartial() for myFClass();
    
    /**
     * \brief Collection of all FFunctionDecls called by a partial function call.
     */
    coll LinkedHashSet<FFunctionDecl> FClass.myFFunctionDeclsPartialCalled() 
        [new LinkedHashSet<FFunctionDecl>()] with add root FClass;
    FPartialFunctionCall contributes myFCallable().actualFFunctionDecl() to FClass.myFFunctionDeclsPartialCalled() for myFClass();

    inh FVariable FIndicatorExp.myIndicatorVariable();
    eq FEquation.getChild().myIndicatorVariable()   = getLeft().asFAccessExp().myFV().asFVariable();
    eq FAssignStmt.getChild().myIndicatorVariable() = getLeft().asFAccessExp().myFV().asFVariable();

    coll ArrayList<FDelayExp> FClass.myDelayExps()
        [new ArrayList<FDelayExp>()] with add root FClass;
    FDelayExp contributes this to FClass.myDelayExps() for myFClass();
    
    syn lazy int FDelayExp.myDelayIndex()  = myFClass().myDelayExps().indexOf(originalFExp());
    syn int FDelayIndicator.myDelayIndex() = myDelayExp().myDelayIndex();
    
    syn FDelayExp FDelayIndicator.myDelayExp() = myFClass().findDelayExp(myIndicatorVariable());
    
    syn lazy FDelayExp FClass.findDelayExp(FVariable indicator) {
        for (FDelayExp delayExp : myDelayExps()) {
            if (delayExp.hasIndicator(indicator)) {
                return delayExp;
            }
        }
        return null;
    }
    
    coll ArrayList<FSpatialDistExp> FClass.mySpatialDistExps()
        [new ArrayList<FSpatialDistExp>()] with add root FClass;
    FSpatialDistExp contributes this to FClass.mySpatialDistExps() for myFClass();
    
    syn lazy int FSpatialDistExp.mySpatialDistIndex()  = myFClass().mySpatialDistExps().indexOf(originalFExp());
    syn int FSpatialDistIndicator.mySpatialDistIndex() = mySpatialDistExp().mySpatialDistIndex();
    
    syn FSpatialDistExp FSpatialDistIndicator.mySpatialDistExp() = myFClass().findSpatialDistExp(myIndicatorVariable());
    
    syn lazy FSpatialDistExp FClass.findSpatialDistExp(FVariable indicator) {
        for (FSpatialDistExp spatialDistExp : mySpatialDistExps()) {
            if (spatialDistExp.hasIndicator(indicator)) {
                return spatialDistExp;
            }
        }
        return null;
    }
    
    
    inh boolean FExp.inDeadIfBranch();
    eq FIfEquation.getFAbstractEquation().inDeadIfBranch() = getTest().inDeadIfBranchTest(false);
    eq FIfEquation.getElse().inDeadIfBranch()              = getTest().inDeadIfBranchTest(true);
    eq FIfExp.getThenExp().inDeadIfBranch()                = getIfExp().inDeadIfBranchTest(false);
    eq FIfExp.getElseExp().inDeadIfBranch()                = getIfExp().inDeadIfBranchTest(true);
    eq FClass.getChild().inDeadIfBranch()                  = false;
    eq InstNode.getChild().inDeadIfBranch()                = false;

    syn boolean FExp.inDeadIfBranchTest(boolean deadValue) = 
        (isConstantExp() && ceval().booleanValue() == deadValue) || inDeadIfBranch();

    syn int FClass.numDerivativeVariables() = derivativeVariables().size();
    coll ArrayList<FDerivativeVariable> FClass.derivativeVariables() 
      [new ArrayList<FDerivativeVariable>()] with add root FClass;
    FDerivativeVariable contributes
        this when (shouldContribute())
    to FClass.derivativeVariables() for myFClass();
    
    syn int FClass.numVariables() = variables().size();
    coll ArrayList<FVariable> FClass.variables() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when !isParameter() && !isConstant() && !isPreVariable() && shouldContribute()
    to FClass.variables() for myFClass();

    syn int FClass.numDiscreteVariables() = discreteVariables().size();
    syn Collection<FVariable> FClass.discreteVariables() = varRefMap().getBy(ZVariability.DISCRETE);

    syn int FClass.numInitialParameters() = initialParameters().size();
    syn Collection<FVariable> FClass.initialParameters() = varRefMap().getBy(ZVariability.INITIAL_PARAMETER);
    
    syn boolean FAbstractVariable.isFixed() = true;
    eq FVariable.isFixed() = !isInitialParameter() && fixedAttribute();
    
    syn boolean FAbstractVariable.isInitialParameter() = false;
    eq FVariable.isInitialParameter()                  = variability().initialParameterVariability();
    
    syn boolean InstComponentDecl.isInitialParameter() = variability().initialParameterVariability();
    
    syn boolean ASTNode.containsFTimeExp() {
        for (ASTNode child : this)
            if (child.containsFTimeExp())
                return true;
        return false;
    }
    eq FTimeExp.containsFTimeExp() = true;
    syn lazy boolean FAbstractEquation.containsFTimeExp() = super.containsFTimeExp();
    
    syn boolean ASTNode.containsFHomotopyExp() {
        for (ASTNode child : this)
            if (child.containsFHomotopyExp())
                return true;
        return false;
    }
    eq FHomotopyExp.containsFHomotopyExp() = true;
    syn lazy boolean FAbstractEquation.containsFHomotopyExp() = super.containsFHomotopyExp();
    public boolean AbstractEquationBlock.containsFHomotopyExp() {
        for (FAbstractEquation eqn : allEquations()) {
            if (eqn.containsFHomotopyExp()) {
                return true;
            }
        }
        return false;
    }
    
    syn int FClass.numDiscretePreVariables() = discretePreVariables().size();
    syn lazy Collection<FVariable> FClass.discretePreVariables() {
        Collection<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : discreteVariables()) {
            l.add((FVariable) lookupFV(fv.getFAccess().preName()));
        }
        for (FVariable fv : continuousVariablesUsedInPreInInitial()) {
            l.add((FVariable) lookupFV(fv.getFAccess().preName()));
        }
        return l;
    }
    
    syn int FClass.numAliasVariables() = aliasVariables().size();
    coll ArrayList<FVariable> FClass.aliasVariables() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when  !isParameter() && !isConstant() && isAlias()
    to FClass.aliasVariables() for myFClass();

    syn int FClass.numAllVariables() = allVariables().size();
    syn lazy ArrayList<FVariable> FClass.allVariables() {
          ArrayList<FVariable> set = new ArrayList<FVariable>();
          for (FVariable fv : getFVariables()) {
                  set.add(fv);
              }
          for (FVariable fv : getAliasVariables()) {
                  set.add(fv);
              }
          return set;
    }

    syn int FClass.numTempVariables() = tempVariables().size();
    coll ArrayList<FVariable> FClass.tempVariables() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isTemporary() && shouldContribute()
    to FClass.tempVariables() for myFClass();

    syn int FClass.numRealVariables() = realVariables().size();
    syn lazy Collection<FRealVariable> FClass.realVariables() = 
            filterCollection(variables(), REAL_VARIABLE_FILTER);

    syn int FClass.numIntegerVariables() = integerVariables().size();
    syn lazy Collection<FIntegerVariable> FClass.integerVariables() =
            filterCollection(variables(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numEnumVariables() = enumVariables().size();
    syn lazy Collection<FEnumVariable> FClass.enumVariables() =
            filterCollection(variables(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanVariables() = booleanVariables().size();
    syn lazy Collection<FBooleanVariable> FClass.booleanVariables() =
            filterCollection(variables(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringVariables() = stringVariables().size();
    syn lazy Collection<FStringVariable> FClass.stringVariables() =
            filterCollection(variables(), STRING_VARIABLE_FILTER);

    syn int FClass.numAlgebraicContinousRealVariables() = algebraicContinousRealVariables().size();
    syn Collection<FVariable> FClass.algebraicContinousRealVariables() = varRefMap().getBy(ZOrdinaryCategory.CONTINUOUS);

    syn int FClass.numNormalAlgebraicContinousRealVariables() = normalAlgebraicContinousRealVariables().size();
    syn lazy Collection<FVariable> FClass.normalAlgebraicContinousRealVariables() {
        // TODO: Refactor to new framework!
        Collection<FVariable> set = new LinkedHashSet<FVariable>();
        for (FVariable var : algebraicContinousRealVariables()) {
            set.add(var);
        }
        set.removeAll(dynamicStates());
        return set;
    }

    public static final VarRefMap.CategoryFilter FClass.ALGEBRAIC_FILTER = new VarRefMap.CategoryFilter() {
        @Override
        protected boolean test(ZOrdinaryCategory category) {
            return category == ZOrdinaryCategory.CONTINUOUS || category.variability == ZVariability.DISCRETE;
        }
        
    };

    syn Collection<FVariable> FClass.algebraicVariables() = varRefMap().getBy(ALGEBRAIC_FILTER);

    syn lazy Collection<FVariable> FClass.normalAlgebraicVariables() {
        Collection<FVariable> set = new LinkedHashSet<FVariable>(algebraicVariables());
        set.removeAll(dynamicStates());
        return set;
    }

    syn int FClass.numVariablesWithBindingExp() = variablesWithBindingExp().size();
    coll ArrayList<FVariable> FClass.variablesWithBindingExp() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes this when 
        !isParameter() && !isConstant() && hasBindingExp() && shouldContribute()
        to FClass.variablesWithBindingExp() for myFClass();

    syn int FClass.numRealVariablesWithBindingExp() = realVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.realVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), REAL_VARIABLE_FILTER);

    syn int FClass.numIntegerVariablesWithBindingExp() = integerVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.integerVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numEnumVariablesWithBindingExp() = enumVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.enumVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanVariablesWithBindingExp() = booleanVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.booleanVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringVariablesWithBindingExp() = stringVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.stringVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), STRING_VARIABLE_FILTER);
     
    syn int FClass.numInputs() = inputs().size();
    coll ArrayList<FVariable> FClass.inputs() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isInput() && shouldContribute()
    to FClass.inputs() for myFClass();

    syn int FVariable.inputIndex() =
        myFClass().inputs().indexOf(this); // TODO: Ouch indexOf in arraylist :(

    syn int FClass.numRealInputs() = realInputs().size();
    syn lazy Collection<FVariable> FClass.realInputs() =
            filterCollection(inputs(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numIntegerInputs() = integerInputs().size();
    syn lazy Collection<FVariable> FClass.integerInputs() =
            filterCollection(inputs(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numEnumInputs() = enumInputs().size();
    syn lazy Collection<FVariable> FClass.enumInputs() =
            filterCollection(inputs(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanInputs() = booleanInputs().size();
    syn lazy Collection<FVariable> FClass.booleanInputs() =
            filterCollection(inputs(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringInputs() = stringInputs().size();
    syn lazy Collection<FVariable> FClass.stringInputs() =
            filterCollection(inputs(), STRING_VARIABLE_FILTER);

    syn int FClass.numOutputs() = outputs().size();
    coll ArrayList<FVariable> FClass.outputs() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isOutput() && shouldContribute()
    to FClass.outputs() for myFClass();

    syn int FClass.numRealOutputs() = realOutputs().size();
    syn lazy Collection<FVariable> FClass.realOutputs() =
            filterCollection(outputs(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numIntegerOutputs() = integerOutputs().size();
    syn lazy Collection<FVariable> FClass.integerOutputs() =
            filterCollection(outputs(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numEnumOutputs() = enumOutputs().size();
    syn lazy Collection<FVariable> FClass.enumOutputs() =
            filterCollection(outputs(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanOutputs() = booleanOutputs().size();
    syn lazy Collection<FVariable> FClass.booleanOutputs() =
            filterCollection(outputs(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringOutputs() = stringOutputs().size();
    syn lazy Collection<FVariable> FClass.stringOutputs() =
            filterCollection(outputs(), STRING_VARIABLE_FILTER);

    syn int FClass.numScalarEquations() {
       int res = 0;
       for (FAbstractEquation e : equations())
               res += e.numScalarEquations();
        for (FVariable fv : getFVariables())
            if (!fv.variability().parameterOrLess() && fv.hasBindingExp())
                res += fv.getBindingExp().type().numScalarElements();
       return res;
    }
    
    		
    syn lazy int FClass.numScalarEquationsAtInitialization() {
        int res = 0;
        for (FAbstractEquation e : equations())
            res += e.numScalarEquations();
        return res;
    }
    syn int FClass.numEquations() = equations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.equations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (!e.isIgnored()) {
                l.add(e);
            }
        }
        return l;
    }

    syn ArrayList<FAbstractEquation> FClass.allEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        l.addAll(equations());
        l.addAll(initialEquations());
        l.addAll(getParameterEquations().toArrayList());
        return l;
    }

    coll ArrayList<FAlgorithm> FClass.algorithms() 
        [new ArrayList<FAlgorithm>()] with add root FClass;
    FAlgorithm contributes this when !inFunction()
        to FClass.algorithms() for myFClass();

    syn int FClass.numContinuousEquations() = continuousEquations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.continuousEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (!e.isIgnored() && e.isContinuous()) {
                l.add(e);
            }
        }
        return l;
    }

    syn int FClass.numContinuousNonMetaEquations() = continuousNonMetaEquations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.continuousNonMetaEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : continuousEquations()) {
            if (!e.isMetaEquation()) {
                l.add(e);
            }
        }
        return l;
    }

    syn int FClass.numScalarVariables() {
        int res = 0;
        for (FVariable fv : getFVariables())
            if (!fv.variability().parameterOrLess())
                res += fv.type().numScalarElements();
        return res;
    }
    
    syn int FType.numScalarElements() = size().numElements();
    eq FRecordType.numScalarElements() {
        int res = 0;
        for (FRecordComponentType c : getComponents())
            res += c.getFType().numScalarElements();
        return res * super.numScalarElements();
    }

    syn int FAbstractEquation.numScalarEquations() = 1;
    eq FEquation.numScalarEquations()           = getLeft().type().numScalarElements();
    eq FConnectClause.numScalarEquations()      = getConnector1().type().numScalarElements();
    syn lazy int FAlgorithm.numScalarEquations() {
        Set<FVariable> assignedVars = new HashSet<FVariable>();
        for (FAccessExp use : FAccessExpsInLHS()) {
            if (!use.myFV().isUnknown() && !assignedVars.contains(use.myFV())) {
                FVariable fv = (FVariable) use.myFV();
                assignedVars.add(fv);
            }
        }
        return assignedVars.size();

    }
    eq FIfWhenElseEquation.numScalarEquations() = numScalarEqnsInList(getFAbstractEquations());
    eq FForClauseE.numScalarEquations()         = 
        numScalarEqnsInList(getFAbstractEquations()) * numForElems(getFForIndexs());
    eq InstForClauseE.numScalarEquations()      = 
        numScalarEqnsInList(getFAbstractEquations()) * numForElems(getInstForIndexs());
    eq FFunctionCallEquation.numScalarEquations() {
        int res = 0;
        for (FFunctionCallLeft l : getLefts())
            res += l.numScalarElements();
        return res;
    }
    
    syn boolean FAbstractEquation.isMetaEquation() = numScalarEquations() == 0;
    
    syn int FFunctionCallLeft.numScalarElements() {
        int res = 0;
        if (hasFExp()) {
            for (FExp exp : flatChildFExps()) {
                res += exp.numScalarElements();
            }
        }
        return res;
    }
    
    syn int FExp.numScalarElements() = type().numScalarElements();
    eq FNoExp.numScalarElements() = 0;

    public Iterable<FExp> FFunctionCallLeft.flatChildFExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        getFExp().flatChildFExps(res);
        return res;
    }
    
    public void FExp.flatChildFExps(ArrayList<FExp> res) {
        res.add(this);
    }
    
    public void FArray.flatChildFExps(ArrayList<FExp> res) {
        for (FExp exp : getFExps()) {
            exp.flatChildFExps(res);
        }
    }
    
    public void FRecordConstructor.flatChildFExps(ArrayList<FExp> res) {
        for (FExp exp : getArgs()) {
            exp.flatChildFExps(res);
        }
    }
    
    

    protected static int FAbstractEquation.numForElems(List<? extends CommonForIndex> list) {
        int res = 1;
        for (CommonForIndex i : list)
            res *= i.size().numElements();
        return res;
    }

    protected static int FAbstractEquation.numScalarEqnsInList(List<FAbstractEquation> list) {
        int res = 0;
        for (FAbstractEquation e : list) 
            res += e.numScalarEquations();
        return res;
    }
    
    
    syn boolean FExp.isTimeEventGenerating() {
        throw new UnsupportedOperationException();
    }
    eq FRelExp.isTimeEventGenerating() =  myOptions().getBooleanOption("time_events") && myOptions().getBooleanOption("relational_time_events") && solutionForTime().isValidExp();
    eq FEqRelExp.isTimeEventGenerating() = false;
    eq FDelayExp.isTimeEventGenerating() = myOptions().getBooleanOption("time_events") && getDelay().variability().parameterOrLess();
    eq FSpatialDistExp.isTimeEventGenerating() = false;
    
    protected int FExp.checkIndex(int i) {
        if (i < 0) {
            throw new UnsupportedOperationException("Unknown switch index for relational operator, not in list of switches.");
        }
        return i;
    }
    
    syn int FClass.numSwitches() = numStateSwitches() + numTimeSwitches();
    syn int FClass.numStateSwitches() = relExpsWithStateEvent().size() + numSpatialDistSwitches() + numDelaySwitches();
    syn int FClass.numTimeSwitches() = relExpsWithTimeEvent().size();
    
    syn int FClass.numEventIndicators() = numStateSwitches();
    
    syn lazy ArrayList<FExp> FClass.switchExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(stateEventExps());
        res.addAll(relExpsWithTimeEvent());
        return res;
    }
    
    syn lazy int FRelExp.mySwitchIndex()   = isTimeEventGenerating() ?
            checkIndex(myFClass().switchExps().indexOf(originalFExp())) + myFClass().delayExpsWithStateEvent().size() :
            myEventIndicatorIndex();
    syn int FDelayExp.mySwitchIndex() = myEventIndicatorIndex();
    
    syn lazy ArrayList<FExp> FClass.stateEventExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(relExpsWithStateEvent());
        res.addAll(spatialDistExpsWithStateEvent());
        res.addAll(delayExpsWithStateEvent());
        return res;
    }
    
    syn lazy int FRelExp.myEventIndicatorIndex()   = checkIndex(myFClass().stateEventExps().indexOf(originalFExp()));
    syn lazy int FSpatialDistExp.myEventIndicatorIndex() = checkIndex(myFClass().stateEventExps().indexOf(originalFExp()));
    syn lazy int FDelayExp.myEventIndicatorIndex() = myFClass().relExpsWithStateEvent().size() + myDelayEventIndicatorIndex();
    
    syn lazy ArrayList<FExp> FClass.timeEventExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(sampleExpsWithTimeEvent());
        res.addAll(relExpsWithTimeEvent());
        return res;
    }
    
    coll ArrayList<FSampleExp> FClass.sampleExpsWithTimeEvent() 
        [new ArrayList<FSampleExp>()] with add root FClass;
    FSampleExp contributes this when generatesEventInDAE()
        to FClass.sampleExpsWithTimeEvent() for myFClass();
    
    syn int FClass.numSpatialDistSwitches() = spatialDistExpsWithStateEvent().size();
    coll ArrayList<FSpatialDistExp> FClass.spatialDistExpsWithStateEvent() 
        [new ArrayList<FSpatialDistExp>()] with add root FClass;
    FSpatialDistExp contributes this when generatesEventInDAE()
        to FClass.spatialDistExpsWithStateEvent() for myFClass();
    
    syn int FClass.numDelaySwitches() = 2*delayExpsWithStateEvent().size();
    coll ArrayList<FDelayExp> FClass.delayExpsWithStateEvent() 
        [new ArrayList<FDelayExp>()] with add root FClass;
    FDelayExp contributes this when generatesEventInDAE() && !isTimeEventGenerating()
        to FClass.delayExpsWithStateEvent() for myFClass();
    
    
    syn int FDelayExp.myDelayEventIndicatorIndex() = 2*checkIndex(myFClass().delayExpsWithStateEvent().indexOf(originalFExp()));
    
    
    syn int FClass.numGuardExpInEquations() = guardExpInEquations().size();
    syn int FClass.numGuardExpInInitialEquations() = guardExpInInitialEquations().size();
    syn int FExp.guardExpInEquationsIndex() = myFClass().guardExpInEquations().indexOf(this);
    syn int FExp.guardExpInInitialEquationsIndex() = myFClass().guardExpInInitialEquations().indexOf(this);

    coll ArrayList<FExp> FClass.guardExpInEquations() 
        [new ArrayList<FExp>()] with addAll root FlatRoot;
    FWhenEquation contributes getTest().guards() when getTest().inEquationSection()
        to FClass.guardExpInEquations() for myFClass();
    FWhenStmt contributes guards() when inEquationSection()
        to FClass.guardExpInEquations() for myFClass();

    coll ArrayList<FExp> FClass.guardExpInInitialEquations() 
        [new ArrayList<FExp>()] with addAll root FlatRoot;
    FWhenEquation contributes getTest().guards() when getTest().inInitialEquationSection()
        to FClass.guardExpInInitialEquations() for myFClass();
    FWhenStmt contributes guards() when inInitialEquationSection()
        to FClass.guardExpInInitialEquations() for myFClass(); 

    coll Set<FExp> FAbstractEquation.transformedGuards() [new HashSet<FExp>()] 
        with add root FAbstractEquation;
    FIfExp contributes getIfExp() when isWhen()
        to FAbstractEquation.transformedGuards() for myFEquation();
    FIfEquation contributes getTest() when isWhen()
        to FAbstractEquation.transformedGuards() for this;

    syn ArrayList<FExp> FWhenStmt.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        for (FIfWhenClause clause : getFIfWhenClauses()) {
            l.addAll(clause.getTest().guards());
        }
        return l;
    }

    syn ArrayList<FExp> FExp.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        l.add(this);
        return l;
    }
    eq FArray.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        for (FExp e : childFExps())
            l.add(e);
        return l;
    }

    syn int FSmoothExp.order() = getOrder().ceval().intValue(); 

    /**
     * Check if an expression will generate an event. Parameters with
     * fixed=false are considered to generate events.
     */
    syn boolean FExp.generatesEvent() = generatesEvent(true);

    /**
     * Check if an expression will generate an event.
     * 
     * @param checkInitialParameters  Controls whether parameters with fixed = false should be
     *                                 considered to generate events.
     */
    syn boolean FExp.generatesEvent(boolean checkInitialParameters) = generatesEvent(false, checkInitialParameters);

    /**
     * Check if an expression will generate an event.
     * 
     * @param ignoreVariability        Controls whether variability should be ignored.
     * @param checkInitialParameters   Controls whether parameters with fixed = false should be
     *                                 considered to generate events.
     */
    syn boolean FExp.generatesEvent(boolean ignoreVariability, boolean checkInitialParameters) =
            inEventGeneratingLocation() && hasEventGeneratingType() &&
            (ignoreVariability || hasEventGeneratingVariability(checkInitialParameters)) &&
            myOptions().getBooleanOption("generate_event_switches");

    /**
     * Check if an expression will generate an event.
     * Does not check context further than expressions.
     */
    syn boolean FExp.hasEventGeneratingVariability(boolean checkInitialParameters) =
            !variability().parameterOrLess() || (checkInitialParameters && variability().initialParameterVariability());

    syn boolean FExp.inEventGeneratingLocation() = !inFunction() && !inNoEventExp() && !inSmoothExp(myOptions().getBooleanOption("disable_smooth_events") ? 0 : 1);

    syn boolean FExp.hasEventGeneratingType() = false;
    eq FRelExp.hasEventGeneratingType()       = isRealComparison();
    eq FEventGenExp.hasEventGeneratingType()  = argType().isReal();
    eq FSpatialDistExp.hasEventGeneratingType() = true;
    eq FDelayExp.hasEventGeneratingType()     = true;
    eq FSampleExp.hasEventGeneratingType()    = true;
    eq FActualStream.hasEventGeneratingType() = true;
    
    syn boolean FExp.generatesEventInDAE() = generatesEventInDAE(originalFExp());
    syn boolean FRelExp.generatesEventInInitDAE() = generatesEventInInitDAE(originalFExp());
    
    syn boolean FExp.generatesEventInDAE(FExp orig) = inEquationSection() && orig==this && generatesEvent(false);
    syn boolean FRelExp.generatesEventInInitDAE(FExp orig) =
            (inInitialEquationSection() || (inEquationSection() && variability().initialParameterVariability()))
            && orig==this && generatesEvent(true);
    
    coll ArrayList<FRelExp> FClass.relExpsWithEvent() 
        [new ArrayList<FRelExp>()] with add root FClass;
    FRelExp contributes this when generatesEventInDAE() 
        to FClass.relExpsWithEvent() for myFClass();
    
    syn ArrayList<FRelExp> FClass.relExpsWithStateEvent() {
        ArrayList<FRelExp> res = new ArrayList<FRelExp>();
        for (FRelExp exp : relExpsWithEvent()) {
            if (!exp.isTimeEventGenerating()) {
                res.add(exp);
            }
        }
        return res;
    }
    
    syn ArrayList<FRelExp> FClass.relExpsWithTimeEvent() {
        ArrayList<FRelExp> res = new ArrayList<FRelExp>();
        for (FRelExp exp : relExpsWithEvent()) {
            if (exp.isTimeEventGenerating()) {
                res.add(exp);
            }
        }
        return res;
    }

    coll ArrayList<FRelExp> FAbstractEquation.relExpInEquation() 
        [new ArrayList<FRelExp>()] with add root FAbstractEquation;
    FRelExp contributes this when generatesEventInDAE(this)
    to FAbstractEquation.relExpInEquation() for myFEquation();

    coll ArrayList<FRelExp> FStatement.relExpInStmt() 
        [new ArrayList<FRelExp>()] with add root FStatement;
    FRelExp contributes this when generatesEventInDAE()
    to FStatement.relExpInStmt() for myFStatement();
    
    coll ArrayList<FDelayExp> FAbstractEquation.delayExpInEquation() 
        [new ArrayList<FDelayExp>()] with add root FAbstractEquation;
    FDelayExp contributes this when generatesEventInDAE()
    to FAbstractEquation.delayExpInEquation() for myFEquation();

    coll ArrayList<FDelayExp> FStatement.delayExpInStmt() 
        [new ArrayList<FDelayExp>()] with add root FStatement;
    FDelayExp contributes this when generatesEventInDAE()
    to FStatement.delayExpInStmt() for myFStatement();
            
    coll ArrayList<FSpatialDistExp> FAbstractEquation.spatialDistExpInEquation() 
        with add root FAbstractEquation;
    FSpatialDistExp contributes this when generatesEventInDAE()
    to FAbstractEquation.spatialDistExpInEquation() for myFEquation();

    coll ArrayList<FSpatialDistExp> FStatement.spatialDistExpInStmt() 
        with add root FStatement;
    FSpatialDistExp contributes this when generatesEventInDAE()
    to FStatement.spatialDistExpInStmt() for myFStatement();
    
    inh FStatement FExp.myFStatement();
    inh FStatement FStatement.myFStatement();
    inh FStatement FIfWhenClause.myFStatement();
    eq FStatement.getChild().myFStatement()        = this;
    eq FAbstractEquation.getChild().myFStatement() = null;
    eq Root.getChild().myFStatement()              = null;
    
    syn int FClass.numInitialEquations() = initialEquations().size(); 
    syn lazy int FClass.numInitialScalarEquations() {
        int res = 0;
        for (FAbstractEquation e : initialEquations())
            res += e.numScalarEquations();
        return res;
    }
    syn lazy ArrayList<FAbstractEquation> FClass.initialEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFInitialEquations()) {
            l.add(e);
        }
        return l;
    }

    syn ArrayList<FAbstractEquation> FClass.normalEquations() = equations();

    syn int FClass.numInitialGuessEquations() {
        int n_eq = 0;
        for (FRealVariable fv : realVariables()) {
            if (!fv.isFixed()) {
                n_eq++;
            }
        }
        return n_eq;
    }
    
    syn int FClass.numInitialEventIndicators() = numRelExpInInitialEquations();
    
    syn ArrayList<FRelExp> FClass.eventExpInInitialEquations() = relExpInInitialEquations();
    
    syn int FClass.numRelExpInInitialEquations() = relExpInInitialEquations().size();
    coll ArrayList<FRelExp> FClass.relExpInInitialEquations()
        [new ArrayList<FRelExp>()] with add root FClass;
    FRelExp contributes this when generatesEventInInitDAE()
    to FClass.relExpInInitialEquations() for myFClass();

    coll ArrayList<FRelExp> FAbstractEquation.relExpInInitialEquation() 
        [new ArrayList<FRelExp>()] with add root FAbstractEquation;
    FRelExp contributes this when generatesEventInInitDAE(this)
    to FAbstractEquation.relExpInInitialEquation() for myFEquation();
    
    syn int FRelExp.relExpInInitialEquationsIndex()  = checkIndex(myFClass().relExpInInitialEquations().indexOf(originalFExp()));

    /**
     * Collects event generating expressions in this statements
     */
    coll ArrayList<FExp> FAbstractEquation.eventGenExps() 
        [new ArrayList<FExp>()] with add root FClass;
    FExp contributes this
        when generatesEvent()
        to FAbstractEquation.eventGenExps()
        for myFEquation();
/*  

    coll ArrayList<FVariable> FClass.structuralParameters() [new ArrayList<FVariable>()] with add root FClass;
    FAccessExp contributes
        (FVariable)myFV() when inArraySubscripts()
    to FClass.structuralParameters() for myFClass();

    coll ArrayList<FEquation> FVariable.variableIncidence() [new ArrayList<FEquation>()] with add root FClass;
    FAccessExp contributes
        myFEquation() when inFEquation()
    to FVariable.variableIncidence() for (FVariable)myFV();
    
    syn lazy ArrayList<ArrayList> FClass.variableIncidence() {
        ArrayList<ArrayList> l = new ArrayList<ArrayList>();
        for (FVariable fv : variables()) {
           l.add(fv.variableIncidence());
       } 
        return l;
    
    }
    
    */
    
    /**
     * Utility function that returns true if this equation on the form zero
     * equal to zero.
     */
    syn boolean FAbstractEquation.isZeroEquation() = false;
    eq FEquation.isZeroEquation() = getLeft().isLiteralZero() && getRight().isLiteralZero();
    
    
    inh Set<FVariable> FExp.boundParameters();
    eq FVariable.getBindingExp().boundParameters()       = Collections.singleton(this);
    eq Root.getChild().boundParameters()                 = Collections.emptySet();
    eq FEquation.getRight().boundParameters()            = boundParameters();
    eq FFunctionCallEquation.getCall().boundParameters() = boundParameters();

    syn Set<FVariable> FAbstractEquation.boundParameters() = Collections.emptySet();
    eq FEquation.boundParameters() {
        if (isParameterEquation()) {
            return getLeft().referencedParametersInFExp();
        } else {
            return Collections.emptySet();
        }
    }
    
    syn Set<FVariable> FAbstractEquation.RHSVariables() = Collections.emptySet();
    eq FEquation.RHSVariables() {
        if (isParameterEquation()) {
            return getRight().referencedParametersInFExp();
        } else {
            return Collections.emptySet();
        }
    }
        
    eq FFunctionCallEquation.boundParameters() { 
        if (isParameterEquation()) { 
            return referencedParametersInLHS(); 
        } else {
            return Collections.emptySet();
        }
    }
    
    syn Set<FVariable> FAbstractVariable.myParameterDependencies() = Collections.emptySet();
    syn lazy Set<FVariable> FVariable.myParameterDependencies() {
        HashSet<FVariable> varSet = new HashSet<FVariable>();
        if (hasParameterEquation()) {
            for (FVariable vv: parameterEquation().RHSVariables()) {
                varSet.addAll(vv.myParameterDependencies());
            }
            return varSet;
        } else { //Base case
            varSet.add(this);
            return varSet;
        }
    }
    
    inh boolean FExp.inFEquation();
    eq FAbstractEquation.getChild().inFEquation()=true;
    eq Root.getChild().inFEquation()=false;
    
    inh FAbstractEquation FExp.myFEquation();
    inh FAbstractEquation FStatement.myFEquation();
    eq FAbstractEquation.getChild().myFEquation() = this;
    eq Root.getChild().myFEquation()              = null;
    
    inh FClass FAbstractVariable.myFClass();
    inh FClass FExp.myFClass();
    inh FClass FType.myFClass();
    inh FClass CommonAccess.myFClass();
    inh FClass FAccess.myFClass();
    inh FClass FFunctionDecl.myFClass();
    inh FClass FRecordDecl.myFClass();
    inh FClass FAlgorithm.myFClass();
    inh FClass FAbstractEquation.myFClass();
    inh FClass FStatement.myFClass();
    inh FClass FFunctionCallLeft.myFClass();
    inh lazy FClass FExternalStmt.myFClass();
    eq FClass.getChild().myFClass() = this;
    eq Root.getChild().myFClass() = null; 
    
    public Iterable<FAbstractEquation> FExp.enclosingEquationsIterator() {
        return myFEquation().enclosingEquationsIterator();
    }

    public Iterable<FAbstractEquation> FStatement.enclosingEquationsIterator() {
        return myFEquation().enclosingEquationsIterator();
    }
    
    inh FAbstractEquation FAbstractEquation.enclosingEquation();
    eq FAbstractEquation.getChild().enclosingEquation() = this;
    eq Root.getChild().enclosingEquation()              = null;
    
    /**
     * Returns the outermost enclosing equation or the equation itself if it is
     * the outermost.
     */
    syn FAbstractEquation FAbstractEquation.outermostEnclosingEquation() {
        FAbstractEquation enclosing = this;
        FAbstractEquation next = enclosingEquation();
        while (next != null) {
            enclosing = next;
            next = enclosing.enclosingEquation();
        }
        return enclosing;
    }
    
    /**
     * Returns an iterable that can be used to iterate over all surounding
     * equations (including this one).
     */
    public Iterable<FAbstractEquation> FAbstractEquation.enclosingEquationsIterator() {
        return new Iterable<FAbstractEquation>() {

            @Override
            public Iterator<FAbstractEquation> iterator() {
                return new Iterator<FAbstractEquation>() {

                    private FAbstractEquation next = FAbstractEquation.this;
                    
                    @Override
                    public boolean hasNext() {
                        return next != null;
                    }

                    @Override
                    public FAbstractEquation next() {
                        FAbstractEquation res = next;
                        next = next.enclosingEquation();
                        return res;
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                    
                };
            }
            
        };
    }
    
    syn lazy boolean FVariable.isIndependentConstant() = isConstant();
    syn lazy boolean FVariable.isDependentConstant() = false;
    
    syn boolean FAbstractVariable.isDependentParameter() = false;
    syn lazy boolean FVariable.isDependentParameter() = 
        isParameter() && !isIndependentParameter();
    
    syn boolean FAbstractVariable.isIndependentParameter() = false;
    syn lazy boolean FVariable.isIndependentParameter() =
            isParameter() && !isInitialParameter() && !hasParameterEquation() && 
            (!hasBindingExp() || getBindingExp().isIndependentParameterExp());
    
    syn lazy boolean FVariable.isRegularIndependentParameter() =
        isIndependentParameter() && !variability().knownParameterOrLess();
    syn lazy boolean FVariable.isStructuralIndependentParameter() =
        isIndependentParameter() && variability().knownParameterOrLess();
    syn lazy boolean FVariable.isFinalIndependentParameter() =
        false; // TODO
    syn lazy boolean FVariable.isEvalIndependentParameter() =
        false; // TODO

    syn boolean FExp.isIndependentParameterExp() = isConstantExp() && !hasCompositeFunc();
    
    inh boolean FAbstractEquation.isParameterEquation();
    eq FClass.getParameterEquation().isParameterEquation() = true;
    eq Root.getChild().isParameterEquation() = false;
    
    inh boolean FAbstractEquation.isNormalEquation();
    eq FClass.getFAbstractEquation().isNormalEquation() = true;
    eq FClass.getChild().isNormalEquation()             = false;
    eq InstNode.getChild().isNormalEquation()           = true;
    eq Root.getChild().isNormalEquation()               = false;
    
    inh List<FAbstractEquation> FAbstractEquation.myFAbstractEquationList();
    eq FClass.getFAbstractEquation().myFAbstractEquationList() = getFAbstractEquations();
    eq FClass.getFInitialEquation().myFAbstractEquationList() = getFInitialEquations();
    eq FClass.getParameterEquation().myFAbstractEquationList() = getParameterEquations();
    eq FClass.getChild().myFAbstractEquationList() = null;
    eq Root.getChild().myFAbstractEquationList() = null;
    
    coll ArrayList<FExp> FAbstractEquation.replacedAtInitialExps()
        [new ArrayList<FExp>()] with add root FAbstractEquation;
    FDelayExp contributes this
        to FAbstractEquation.replacedAtInitialExps() for myFEquation();
    FSpatialDistExp contributes this
        to FAbstractEquation.replacedAtInitialExps() for myFEquation();
    
    syn boolean FAbstractEquation.replacedAtInitialization() = 
            isWhen() || replacedAtInitialExps().size() > 0;
    eq FAlgorithm.replacedAtInitialization() {
        if (super.replacedAtInitialization())
            return true;
        
        /* 
         * Even if there are no when statements, there might still be discrete 
         * variables which are dependent on their pre() variables 
         */
        Set<FVariable> notDefSet = referencedFVariablesInLHS();
        notDefSet.removeAll(defSet());
        for (FVariable fv : notDefSet)
            if (fv.isDiscrete())
                return true;
        return false;
    }
    
    syn List<FAbstractEquation> FAbstractEquation.getInitialEquationList() {
        List<FAbstractEquation> l = new List<FAbstractEquation>();
        if (replacedAtInitialization()) {
            l.add((FAbstractEquation) copySymbolic());
        }
        return l;
    }
    
    eq FIfEquation.getInitialEquationList() {
        return createInitialEquationList();
    }
    
    syn List<FAbstractEquation> FIfWhenElseEquation.createInitialEquationList() {
        List<FAbstractEquation> l = new List<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (e.replacedAtInitialization()) {
                l.addAll(e.getInitialEquations());
            } else {
                l.add(e.copySymbolic());
            }
        }
        return l;
    }
    
    eq FIfWhenEquation.createInitialEquationList() {
        if (getTest().isInitialGuard())
            return super.createInitialEquationList();
        else if (hasElse())
            return getElse().createInitialEquationList();
        else
            return new List<FAbstractEquation>();
    }
    

    rewrite FIfExp {
        when (isWhen() && isInitial()) to FExp {
            if (getIfExp().isInitialGuard())
                return getThenExp();
            else
                return getElseExp();
        }
    }
    
    rewrite FDelayExp {
        when (isInitial()) to FExp {
            return getFExp().copySymbolic();
        }
    }
    
    rewrite FSpatialDistExp {
        when (isInitial() && !isFunctionCallClause()) to FExp {
            return createInitialReplacement(false);
        }
    }
    
    public FExp FSpatialDistExp.createInitialReplacement(boolean second) {
        int size = getInitialValues().size().numElements();
        return new FIfExp(getPositiveVelocity().copySymbolic(),
                getInitialValues().getArray().get(second ? size : 1).copySymbolic(), 
                getInitialValues().getArray().get(second ? 1 : size).copySymbolic());
    }
    
    eq FFunctionCallEquation.getInitialEquationList() {
        if (getCall() instanceof FSpatialDistExp) {
            FSpatialDistExp call = (FSpatialDistExp) getCall();
            ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
            if (getNumLeft() > 0 && getLeft(0).hasFExp()) {
                l.add(new FEquation(getLeft(0).getFExp().copySymbolic(), call.createInitialReplacement(false)));
            }
            if (getNumLeft() > 1 && getLeft(1).hasFExp()) {
                l.add(new FEquation(getLeft(1).getFExp().copySymbolic(), call.createInitialReplacement(true)));
            }
            return new List<FAbstractEquation>(l);
        }
        return super.getInitialEquationList();
    }
    
    eq FAlgorithm.getInitialEquationList() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        
        // Keeps FAccessExps in lhs which have not been removed
        Set<FAccessExp> usesLHS = FAccessExpsInLHS();
        
        // Keeps track of which variables are definetly set
        Set<FVariable> fvSet  = new HashSet<FVariable>();
        Set<FVariable> fvUse  = new HashSet<FVariable>();
        
        // Create a new algorithm with some statements removed
        ArrayList<FStatement> stmts = new ArrayList<FStatement>();
        for (FStatement stmt : getFStatements()) {
            stmt.addAsInitial(stmts, usesLHS, fvSet, fvUse);
        }
        
        Set<FVariable> lhs = lookupFVariablesInSet(usesLHS);

        // Add initial statements for variables which are not definetly set
        // in the new algorithm
        ArrayList<FStatement> initStmts = new ArrayList<FStatement>();
        for (FVariable fv : lhs)
            if (!fvSet.contains(fv))
                initStmts.add(new FAssignStmt(fv.createAccessExp(), fv.createAlgorithmArgument(true)));
        for (FStatement stmt : stmts)
            initStmts.add(stmt);
        if (initStmts.size() > 0)
            l.add(new FAlgorithm(new List<FStatement>(initStmts)));
        
        // Create equations for variables which are no longer assigned 
        // in the new algorithm
        Set<FVariable> removedFVs = referencedFVariablesInLHS();
        removedFVs.removeAll(lhs);
        for (FVariable fv : removedFVs)
            l.add(new FEquation(fv.createAccessExp(), fv.createFPreExp()));
        
        return new List<FAbstractEquation>(l);
    }
    
    
    public void FStatement.addAsInitial(ArrayList<FStatement> stmts, Set<FAccessExp> usesLHS, 
            Set<FVariable> fvSet, Set<FVariable> fvUse) {
        
        defSet(fvSet, fvUse);
        stmts.add(copySymbolic());
    }
    public void FIfStmt.addAsInitial(ArrayList<FStatement> stmts, Set<FAccessExp> usesLHS, 
            Set<FVariable> fvSet, Set<FVariable> fvUse) {
        
        if (!isWhen()) {
            super.addAsInitial(stmts, usesLHS, fvSet, fvUse);
            return;
        }
        
        boolean first = true;
        for (FIfWhenClause c : getFIfWhenClauses()) {
            if (c.getTest().isInitialGuard() && first) {
                for (FStatement s : c.getFStatements()) {
                    s.defSet(fvSet, fvUse);
                    stmts.add(s.copySymbolic());
                }
                first = false;
            } else {
                usesLHS.removeAll(c.findFAccessExpsInTree());
            }
        }
    }
    
    syn boolean FExp.isInitialGuard() = false;
    eq FInitialExp.isInitialGuard() = true;
    eq FOrExp.isInitialGuard() = getLeft().isInitialGuard() || getRight().isInitialGuard();
            
    /**
     * Find LHS variables which are definetly assigned to before any use.
     */
    public Set<FVariable> FAlgorithm.defSet() {
        HashSet<FVariable> fvSet = new HashSet<FVariable>();
        HashSet<FVariable> fvUse = new HashSet<FVariable>();
        for (FStatement stmt : getFStatements()) {
            stmt.defSet(fvSet, fvUse);
        }
        return fvSet;
    }
    public void FStatement.defSetAdd(Set<FVariable> s1, Set<FVariable> s2, Collection<FVariable> fvs) {
        for (FVariable fv : fvs)
            if (!s1.contains(fv))
                s2.add(fv);
    }
    public void FStatement.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(FAccessExpsInRHS()));
    }
    public void FAssignStmt.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(getRight().findFAccessExpsInTree()));
        defSetAdd(fvUse, fvSet, lookupFVariablesInSet(getLeft().findFAccessExpsInTree()));
    }
    public void FFunctionCallStmt.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(getCall().findFAccessExpsInTree()));
        for (FFunctionCallLeft left : getLefts())
            if (left.hasFExp())
                defSetAdd(fvUse, fvSet, lookupFVariablesInSet(left.getFExp().findFAccessExpsInTree()));
    }
    
    /**
     * Check if tree contains a function call returning an array or a record.
     */
    syn boolean ASTNode.hasCompositeFunc() {
        for (ASTNode n : this)
            if (n.hasCompositeFunc())
                return true;
        return false;
    }
    eq InstFunctionCall.hasCompositeFunc() = 
        type().isArray() || type().isRecord() || super.hasCompositeFunc();
    eq FFunctionCall.hasCompositeFunc()    = 
        type().isArray() || type().isRecord() || super.hasCompositeFunc();
    
    syn boolean FVariable.hasParamValueExp() = hasBindingExp() || startAttributeSet();
    syn FExp FVariable.paramValueExp() = hasBindingExp() ? getBindingExp() : startAttributeExp();
    
    syn boolean FVariable.isVariable() = !isParameter() && !isConstant();
    
    syn boolean FAbstractVariable.isFVariable() = false;
    eq FVariable.isFVariable()                  = true;

    syn boolean FAbstractVariable.isFRealVariable() = false;
    eq FRealVariable.isFRealVariable()              = true;
    
    syn boolean FAbstractVariable.isFFunctionVariable() = false;
    eq FFunctionVariable.isFFunctionVariable()          = true;

    syn boolean FAbstractVariable.isDifferentiatedVariable() = false;
    syn lazy boolean FVariable.isDifferentiatedVariable() = zVariability() == FClass.ZVariability.DIFFERENTIATED;
    syn boolean FDynamicStateVariable.isDifferentiatedVariable() = true;

    syn boolean FAbstractVariable.isAbstractDerivativeVariable() = false;
    eq FAbstractDerivativeVariable.isAbstractDerivativeVariable() = true;

    syn boolean FAbstractVariable.isDerivativeVariable() = false;
    eq FDerivativeVariable.isDerivativeVariable() = true;

    syn FVariable FAbstractVariable.asFVariable() {
        throw new UnsupportedOperationException("asFVariable() is not supported for class type " + getClass().getSimpleName());
    }
    eq FVariable.asFVariable() = this;

    syn FRealVariable FAbstractVariable.asFRealVariable() {
        throw new UnsupportedOperationException("asFRealVariable() is not supported for class type " + getClass().getSimpleName());
    }
    eq FRealVariable.asFRealVariable() = this;
    
    syn FDerivativeVariable FAbstractVariable.asDerivativeVariable() {
        throw new UnsupportedOperationException("isDerivativeVariable() is not supported for class type " + getClass().getSimpleName());
    }
    eq FDerivativeVariable.asDerivativeVariable() = this;

    syn boolean FAbstractVariable.isDummyDerivativeVariable() = false;
    eq FDummyDerivativeVariable.isDummyDerivativeVariable() = true;

    syn boolean FAbstractVariable.isNonDummyDerivativeVariable()  = false;
    eq FAbstractDerivativeVariable.isNonDummyDerivativeVariable() = true;
    eq FDummyDerivativeVariable.isNonDummyDerivativeVariable()    = false;

    syn boolean FAbstractVariable.isDynamicDerivativeVariable() = false;
    eq FDynamicDerivativeVariable.isDynamicDerivativeVariable() = true;
    
    syn boolean FAbstractVariable.isPreVariable() = false;
    eq FPreRealVariable.isPreVariable() = true;
    eq FPreIntegerVariable.isPreVariable() = true;
    eq FPreBooleanVariable.isPreVariable() = true;
    eq FPreStringVariable.isPreVariable() = true;
    eq FPreEnumVariable.isPreVariable() = true;
    
    syn boolean FAbstractVariable.isAlgebraicVariable() = false;
    syn boolean FVariable.isAlgebraicVariable()    = FClass.ALGEBRAIC_FILTER.testSingle(zCategory());

    syn boolean FAbstractVariable.isDiscreteVariable() = false;
    syn boolean FVariable.isDiscreteVariable()    = zVariability() == FClass.ZVariability.DISCRETE;

    syn boolean FAbstractVariable.isAlgebraicContinousRealVariable() = false;
    syn boolean FVariable.isAlgebraicContinousRealVariable()    = zCategory() == FClass.ZOrdinaryCategory.CONTINUOUS;

    syn GUIDManager FClass.guidManager() = root().getUtilInterface().getGuidManager();

    // TODO: This should be handled with a local map when needed, e.g. during
    // index reduction!
    @Deprecated
    private FVariable FVariable.meDifferentiated = null;
    @Deprecated
    private FVariable FVariable.meIntegrated = null;

    @Deprecated
    public void FVariable.setMeDifferentiated(FVariable var) {
        this.meDifferentiated = var;
    }

    /**
     * This method should only be used during index reduction where we can't
     * use variable lookup to resolve higher and lower order variables!
     * Instead, please use {@link #myDerivativeVariable()} instead!
     */
    @Deprecated
    public FVariable FVariable.getMeDifferentiated() {
        return this.meDifferentiated;
    }

    @Deprecated
    public void FVariable.setMeIntegrated(FVariable var) {
        this.meIntegrated = var;
    }

    /**
     * This method should only be used during index reduction where we can't
     * use variable lookup to resolve higher and lower order variables!
     * Instead, please use {@link #myDifferentiatedVariable()} instead!
     */
    @Deprecated
    public FVariable FVariable.getMeIntegrated() {
        return this.meIntegrated;
    }

    @Deprecated
    public FVariable FVariable.getTopIntegrated() {
        FVariable fv = this;
        while (fv.meIntegrated != null)
            fv = fv.meIntegrated;
        return fv;
    }

    // TODO: Unlike higher and lower order function on variables, this one
    // actually doesn't have any corresponding constructions, so we might
    // actually wan't to keep this functionality. However we should probably
    // move it to tokens or similar.
    @Deprecated
    private FAbstractEquation FAbstractEquation.meDifferentiated = null;

    @Deprecated
    private FAbstractEquation FAbstractEquation.meIntegrated = null;

    @Deprecated
    public void FAbstractEquation.setMeDifferentiated(FAbstractEquation e) {
        this.meDifferentiated = e;
    }

    @Deprecated
    public FAbstractEquation FAbstractEquation.getMeDifferentiated() {
        return this.meDifferentiated;
    }

    @Deprecated
    public void FAbstractEquation.setMeIntegrated(FAbstractEquation e) {
        this.meIntegrated = e;
    }

    @Deprecated
    public FAbstractEquation FAbstractEquation.getMeIntegrated() {
        return this.meIntegrated;
    }
}

aspect ReferencedVariables {
    
    public interface CommonAccessExpLookupVisitor<T extends CommonAccessExp> {
        public void visit(ASTNode<? extends ASTNode> node, Set<T> set);
        public abstract void add(CommonAccessExp access, Set<T> set);
    }
    
    public abstract class InstAccessExpLookupVisitor implements CommonAccessExpLookupVisitor<InstAccessExp> {
        @Override
        public void add(CommonAccessExp access, Set<InstAccessExp> set) {
            access.addToInstAccessExpSet(set);
        }
    }

    public abstract class FAccessExpLookupVisitor implements CommonAccessExpLookupVisitor<FAccessExp> {
        @Override
        public void add(CommonAccessExp access, Set<FAccessExp> set) {
            access.addToFAccessExpSet(set);
        }
    }

    public class DefaultInstAccessExpLookupVisitor extends InstAccessExpLookupVisitor {
        public static final DefaultInstAccessExpLookupVisitor instance = new DefaultInstAccessExpLookupVisitor();
        
        @Override
        public void visit(ASTNode<? extends ASTNode> node, Set<InstAccessExp> set) {
            node.findCommonAccessExpsInTree(set, this);
        }
    }
    
    public class DefaultFAccessExpLookupVisitor extends FAccessExpLookupVisitor {
        public static final DefaultFAccessExpLookupVisitor instance = new DefaultFAccessExpLookupVisitor();
        
        @Override
        public void visit(ASTNode<? extends ASTNode> node, Set<FAccessExp> set) {
            node.findCommonAccessExpsInTree(set, this);
        }
    }
    
    public void CommonAccessExp.addToInstAccessExpSet(Set<InstAccessExp> set) {}
    public void InstAccessExp.addToInstAccessExpSet(Set<InstAccessExp> set) {
        set.add(this);
    }

    public void CommonAccessExp.addToFAccessExpSet(Set<FAccessExp> set) {}
    public void FAccessExp.addToFAccessExpSet(Set<FAccessExp> set) {
        set.add(this);
    }

    public Set<InstAccessExp> ASTNode.findInstAccessExpsInTree() {
        return findCommonAccessExpsInTree(DefaultInstAccessExpLookupVisitor.instance);
    }

    public Set<FAccessExp> ASTNode.findFAccessExpsInTree() {
        return findCommonAccessExpsInTree(DefaultFAccessExpLookupVisitor.instance);
    }
    
    public <T extends CommonAccessExp> Set<T> ASTNode.findCommonAccessExpsInTree(CommonAccessExpLookupVisitor<T> visitor) {
        Set<T> set = new LinkedHashSet<>();
        visitor.visit(this, set);
        return set;
    }
    
    public <T extends CommonAccessExp> void ASTNode.findCommonAccessExpsInTree(Set<T> set, CommonAccessExpLookupVisitor<T> visitor) {
        for (ASTNode n : this) {
            visitor.visit(n, set);
        }
    }

    @Override
    public <T extends CommonAccessExp> void CommonAccessExp.findCommonAccessExpsInTree(Set<T> set, CommonAccessExpLookupVisitor<T> visitor) {
        visitor.add(this, set);
        super.findCommonAccessExpsInTree(set, visitor);
    }

    @Override
    public <T extends CommonAccessExp> void FRelExp.findCommonAccessExpsInTree(Set<T> set, CommonAccessExpLookupVisitor<T> visitor) {
        if (!hasIndicator()) {
            super.findCommonAccessExpsInTree(set, visitor);
        } else {
            for (ASTNode<?> n : this) {
                if (n != getIndicatorOpt()) {
                    n.findCommonAccessExpsInTree(set, visitor);
                }
            }
        }
    }

    @Override
    public <T extends CommonAccessExp> void FAttribute.findCommonAccessExpsInTree(Set<T> set, CommonAccessExpLookupVisitor<T> visitor) {
    }

    syn Set<FAccessExp> FAbstractEquation.FAccessExpsInRHS() = FAccessExpsInRHS(DefaultFAccessExpLookupVisitor.instance);

    syn Set<FAccessExp> FAbstractEquation.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor)
        = Collections.emptySet();
    eq FEquation.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor)
        = getRight().findCommonAccessExpsInTree(visitor);
    eq FFunctionCallEquation.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor)
        = getCall().findCommonAccessExpsInTree(visitor);
    eq FAlgorithm.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<FAccessExp>();
        for (FStatement stmt : getFStatements())
            res.addAll(stmt.FAccessExpsInRHS(visitor));
        return res;
    }

    syn Set<FAccessExp> FStatement.FAccessExpsInRHS() = FAccessExpsInRHS(DefaultFAccessExpLookupVisitor.instance);

    syn Set<FAccessExp> FStatement.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<>();
        for (FAccessExp use : findCommonAccessExpsInTree(visitor))
            if (!use.useIsAssignment() && !use.myFV().isForIndex())
                res.add(use);
        res.removeAll(FAccessExpsInLHS(visitor));
        return res;
    }
    
    eq FIfWhenElseEquation.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<FAccessExp>();
        for (FAbstractEquation fae : getFAbstractEquations())
            res.addAll(fae.FAccessExpsInRHS(visitor));
        return res;
    }
    
    eq FIfWhenEquation.FAccessExpsInRHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = super.FAccessExpsInRHS(visitor);
        getTest().findCommonAccessExpsInTree(res, visitor);
        if (hasElse())
            res.addAll(getElse().FAccessExpsInRHS(visitor));
        return res;
    }
    
    syn Set<FAccessExp> FAbstractEquation.FAccessExpsInLHS() = FAccessExpsInLHS(DefaultFAccessExpLookupVisitor.instance);
    
    syn Set<FAccessExp> FAbstractEquation.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) = Collections.emptySet();
    eq FEquation.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor)             = getLeft().findCommonAccessExpsInTree(visitor);
    eq FFunctionCallEquation.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) = getLefts().findCommonAccessExpsInTree(visitor);
    eq FAlgorithm.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<FAccessExp>();
        for (FStatement stmt : getFStatements())
            res.addAll(stmt.FAccessExpsInLHS(visitor));
        return res;
    }
    
    syn Set<FAccessExp> FStatement.FAccessExpsInLHS() = FAccessExpsInLHS(DefaultFAccessExpLookupVisitor.instance);
    
    syn Set<FAccessExp> FStatement.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<>();
        for (FAccessExp use : findCommonAccessExpsInTree(visitor))
            if (use.useIsAssignment() && !use.myFV().isForIndex())
                res.add(use);
        return res;
    }
    
    eq FIfWhenElseEquation.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = new LinkedHashSet<FAccessExp>();
        for (FAbstractEquation fae : getFAbstractEquations())
            res.addAll(fae.FAccessExpsInLHS(visitor));
        return res;
    }
    
    eq FIfWhenEquation.FAccessExpsInLHS(CommonAccessExpLookupVisitor<FAccessExp> visitor) {
        Set<FAccessExp> res = super.FAccessExpsInLHS(visitor);
        if (hasElse())
            res.addAll(getElse().FAccessExpsInLHS(visitor));
        return res;
    }
    
    syn ArrayList<FAccessExp> FAbstractEquation.uniqueFAccessExpsInLHS() {
        ArrayList<FAccessExp>   res   = new ArrayList<>();
        Set<FAbstractVariable> visit = new LinkedHashSet<FAbstractVariable>();
        for (FAccessExp e : FAccessExpsInLHS()) {
            FAbstractVariable fv = e.myFV();
            if (!visit.contains(fv)) {
                visit.add(fv);
                res.add(e);
            }
        }
        return res;
    }

    syn lazy Set<FAccessExp> FAbstractEquation.referencedCommonAccessExps() {
        Set<FAccessExp> res = new LinkedHashSet<>();
        res.addAll(FAccessExpsInLHS());
        res.addAll(FAccessExpsInRHS());
        return res;
    }

    /***
     * DANGER! Use this method and its results with caution. It will probably
     * not work before saclarization but should be safe afterwards!
     */
    syn Set<String> FAbstractEquation.referencedVariablesAsStrings() {
        Set<FAccessExp> exps = new LinkedHashSet<FAccessExp>();
        Set<String> res = new LinkedHashSet<String>();
        for (FAccessExp exp : exps) {
            res.add(exp.name());
        }
        return res;
    }
    public static Set<FVariable> ASTNode.lookupFVariablesInSet(Set<FAccessExp> set) {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FAccessExp use : set)
            if (use.myFV() instanceof FVariable)
                res.add((FVariable) use.myFV());
        return res;
    }

    syn Set<FVariable> FAbstractEquation.variableDependenciesRHS() = referencedFVariablesInRHS();
    eq FAlgorithm.variableDependenciesRHS() {
        Set<FVariable> lhs = referencedFVariablesInLHS();
        Set<FVariable> rhs = referencedFVariablesInRHS();
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FVariable fv : rhs) {
            if (!lhs.contains(fv)) {
                res.add(fv);
            }
        }
        return res;
    }
    
    syn Set<FVariable> FAbstractEquation.referencedFVariablesInRHS() = lookupFVariablesInSet(FAccessExpsInRHS());
    syn Set<FVariable> FAbstractEquation.referencedFVariablesInLHS() = lookupFVariablesInSet(FAccessExpsInLHS());
    // Lazy is needed for FAlgorithms since the can have large number of scalars
    syn lazy Set<FVariable> FAlgorithm.referencedFVariablesInLHS() = super.referencedFVariablesInLHS();
    syn Set<FVariable> FExp.referencedFVariablesInFExp()             = lookupFVariablesInSet(findFAccessExpsInTree());
    syn Set<FVariable> FVariable.referencedFVariablesInBindingExp()  = lookupFVariablesInSet(getBindingExp().findFAccessExpsInTree());
    syn lazy Set<FVariable> FAbstractEquation.referencedFVariables() = lookupFVariablesInSet(referencedCommonAccessExps());

    public static Set<FVariable> ASTNode.parametersInSet(Set<? extends FVariable> set) {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FVariable fv : set)
            if (fv.isParameter())
                res.add(fv);
        return res;
    }
    
    syn Set<FVariable> FFunctionCallEquation.referencedParametersInLHS() = parametersInSet(referencedFVariablesInLHS());
    syn Set<FVariable> FExp.referencedParametersInFExp()                 = parametersInSet(referencedFVariablesInFExp());

    syn boolean FAbstractEquation.assignedInAllBranches(FAbstractVariable var) = true;
    eq FEquation.assignedInAllBranches(FAbstractVariable var) = assignedInAllBranchesVariables().contains(var.name());

    syn lazy Set<String> FEquation.assignedInAllBranchesVariables() {
        Set<String> res = new HashSet<String>();
        getLeft().assignedInAllBranchesVariables(res);
        getRight().assignedInAllBranchesVariables(res);
        return res;
    }

    public final Set<String> FExp.assignedInAllBranchesVariables() {
        Set<String> res = new HashSet<String>();
        assignedInAllBranchesVariables(res);
        return res;
    }

    public void FExp.assignedInAllBranchesVariables(Set<String> res) {
        for (FExp exp : childFExps())
            exp.assignedInAllBranchesVariables(res);
    }

    @Override
    public void FAccessExp.assignedInAllBranchesVariables(Set<String> res) {
        res.add(name());
    }

    @Override
    public void FIfExp.assignedInAllBranchesVariables(Set<String> res) {
        getIfExp().assignedInAllBranchesVariables(res);
        Set<String> a = getThenExp().assignedInAllBranchesVariables();
        Set<String> b = getElseExp().assignedInAllBranchesVariables();
        if (a.size() > b.size()) {
            Set<String> tmp = a;
            a = b;
            b = tmp;
        }
        for (String name : a) {
            if (b.contains(name)) {
                res.add(name);
            }
        }
    }
}


aspect FlatEnumerations {
    
    public ArrayList<FEnumLiteral> FEnumDecl.enumLiterals() {
        return getFEnumSpecification().enumLiterals();
    }

    public ArrayList<FEnumLiteral> FEnumSpecification.enumLiterals() {
        return new ArrayList<FEnumLiteral>();
    }

    public ArrayList<FEnumLiteral> FEnumLiteralList.enumLiterals() {
        ArrayList<FEnumLiteral> l = new ArrayList<FEnumLiteral>();
        for (FEnumLiteral el : getFEnumLiterals()) {
            l.add(el);
        }
        return l;
    }
    
    /**
     * The number of enumeration literals defined in the enumeration this variable is of.
     */
    syn int FEnumVariable.numEnumLiterals() = myFEnumDecl().numEnumLiterals();
    
    /**
     * The number of enumeration literals defined in this enumeration.
     */
    syn int FEnumDecl.numEnumLiterals() = getFEnumSpecification().numEnumLiterals();
    
    /**
     * The number of enumeration literals defined in this enumeration.
     */
    syn int FEnumSpecification.numEnumLiterals() = 0;
    eq FEnumLiteralList.numEnumLiterals() = getNumFEnumLiteral();
    
}

aspect FlatCausality {
    
    syn boolean FAbstractVariable.isInput() = false;
    eq FVariable.isInput() = getTypePrefixInputOutput().inputCausality();
    syn boolean FAbstractVariable.isOutput() = false;
    eq FVariable.isOutput() = getTypePrefixInputOutput().outputCausality();
      
}

aspect FlatTypes {

    syn boolean FAbstractVariable.isReal()              = type().isReal();
    syn boolean FAbstractVariable.isInteger()           = type().isInteger();
    syn boolean FAbstractVariable.isBoolean()           = type().isBoolean();
    syn boolean FAbstractVariable.isString()            = type().isString();
    syn boolean FAbstractVariable.isRecord()            = type().isRecord();
    syn boolean FAbstractVariable.isEnum()              = type().isEnum();
    syn boolean FAbstractVariable.isExternalObject()    = type().isExternalObject();
    
    syn boolean FExp.isComposite()              = isArray() || type().isRecord();
    syn boolean FType.isComposite()             = isArray() || isRecord();
    syn boolean FAbstractVariable.isComposite() = isArray() || isRecord();
    syn boolean InstComponentDecl.isComposite() = isArray() || isRecord();
    
    inh boolean FAbstractVariable.inRecord();
    eq FRecordDecl.getChild().inRecord() = true;
    eq FClass.getChild().inRecord()      = false;
    eq FForIndex.getChild().inRecord()   = false;

    inh boolean InstNode.inRecord();
    eq Root.getChild().inRecord()                               = false;
    eq InstClassDecl.getChild().inRecord()                      = false;
    eq InstForIndex.getInstPrimitive().inRecord()               = false;
    eq InstRecord.getChild().inRecord()                         = true;
    eq InstRecordConstructor.getChild().inRecord()              = true;
    eq InstArrayComponentDecl.getInstComponentDecl().inRecord() = inRecord();
    eq InstExtends.getInstComponentDecl().inRecord()            = inRecord();

    inh boolean InstNode.inRecordDecl();
    eq Root.getChild().inRecordDecl()           = false;
    eq InstClassDecl.getChild().inRecordDecl()  = isRecord();

    inh boolean InstComponentDecl.inRecordConstructor();
    inh boolean InstExtends.inRecordConstructor();
    eq InstRecordConstructor.getInstComponentDecl().inRecordConstructor() = true;
    eq InstRecordConstructor.getInstExtends().inRecordConstructor()       = true;
    eq InstExtends.getChild().inRecordConstructor()                       = inRecordConstructor();
    eq InstNode.getChild().inRecordConstructor()                          = false;
    eq Root.getChild().inRecordConstructor()                              = false;

    syn int FRecordDecl.indexOf(String name) {
        for (int i = 0; i < getNumFVariable(); i++)
            if (getFVariable(i).name().equals(name))
                return i;
        return -1;
    }
    
    syn int FRecordDecl.indexOfArg(String name) {
        int k = 0;
        for (int i = 0; i < getNumFVariable(); i++) {
            if (getFVariable(i).modifiableInRecord) {
                if (getFVariable(i).name().equals(name))
                    return k;
                k++;
            }
        }
        return -1;
    }
    
    syn FExp FRecordDecl.extractArg(FRecordConstructor frc, String name) {
        return frc.getArg(indexOf(name));
    }
    
    inh FRecordDecl FExp.containingRecordDecl();
    inh FRecordDecl FAbstractVariable.containingRecordDecl();
    eq FRecordDecl.getChild().containingRecordDecl() = this;
    eq Root.getChild().containingRecordDecl()        = null;

}


aspect Nominals {
    syn FExp FAbstractEquation.nominal() {
        FExp nom = FExp.nominalDefault();
        nom.setParent(this);
        return nom;
    }
    eq FEquation.nominal() {
        FExp nom = getLeft().dynamicFExp(FExp.nominalMax(getLeft(), getRight()));
        if (nom.variability().knownParameterOrLess()) {
            try {
                CValue val = nom.ceval();
                if (val.hasBuildLiteral()) {
                    nom = getLeft().dynamicFExp(val.buildLiteral());
                }
            } catch (ConstantEvaluationException e) {}
        }
        return nom;
    }
    
    public static FExp FExp.nominalMax(FExp e1, FExp e2) {
        return new FMaxExp(e1.nominal(), new Opt<FExp>(e2.nominal()));
    }
    public static FExp FExp.nominalDefault() {
        return new FIntegerLitExp(1);
    }
    
    syn FExp FExp.nominal() = FExp.nominalDefault();
    eq FLitExp.nominal()    = new FAbsExp(fullCopy());
    
    eq FDotAddExp.nominal() = FExp.nominalMax(getLeft(), getRight());
    eq FDotSubExp.nominal() = FExp.nominalMax(getLeft(), getRight());
    eq FDotMulExp.nominal() = new FMulExp(getLeft().nominal(), getRight().nominal());
    eq FDotDivExp.nominal() = new FDivExp(getLeft().nominal(), getRight().nominal());
    eq FNegExp.nominal()    = getFExp().nominal();
    eq FAbsExp.nominal()    = getFExp().nominal();
    eq FMinMaxExp.nominal() = hasY() ? FExp.nominalMax(getX(), getY()) : getX().nominal();
    
    eq FIfExp.nominal()     = FExp.nominalMax(getThenExp(), getElseExp());
    
    eq FNoEventExp.nominal() = getFExp().nominal();
    eq FSmoothExp.nominal()  = getFExp().nominal();
    
    eq FHomotopyExp.nominal()    = FExp.nominalMax(getActual(), getSimplified());
    eq FSpatialDistExp.nominal() = FExp.nominalMax(getIn0(), getIn1());
    eq FDelayExp.nominal()       = getFExp().nominal();
    
    eq FAccessExp.nominal() = myFV().nominal();
    eq FGlobalAccessExp.nominal() = new FAbsExp(treeCopy());
    
    syn FExp FAbstractVariable.nominal() {
        if (variability().fixedParameterOrLess()) {
            return new FAbsExp(createAccessExp());
        } else {
            return variableNominal();
        }
    }
    eq UnknownFVariable.nominal() = variableNominal();
    
    syn FExp FAbstractVariable.variableNominal() {
        return FExp.nominalDefault();
    }
    
    eq FRealVariable.variableNominal() {
        if (nominalAttributeSet()) {
            return new FAbsExp(nominalAttributeExp().unboundCopy());
        } else {
            return super.variableNominal();
        }
    }
}

aspect FVariableUses {
    
    /**
     * Collection attribute returning all variable uses in expressions.
     */
    coll HashSet<FAccessExp> FAbstractVariable.uses() [new LinkedHashSet<>()] 
        with add root FClass;
    
    FAccessExp contributes this to FAbstractVariable.uses() for myFV();
    
    /**
     * All uses of this variable that are not the left-hand side of an equation. 
     * (Unless the variable has a binding expression, then this is the same as uses().)
     */
    syn lazy Set<FAccessExp> FAbstractVariable.nonDefiningUses() {
        Set<FAccessExp> res = new HashSet<FAccessExp>();
        for (FAccessExp use : uses())
            if (hasBindingExp() || !use.isLeftHandSide())
                res.add(use);
        return res;
    }
    
    /**
     * All uses of this variable that are the left-hand side of an equation. 
     * (Unless the variable has a binding expression, then this is empty.)
     */
    syn lazy Set<FAccessExp> FAbstractVariable.definingUses() {
        if (hasBindingExp()) {
            return Collections.emptySet();
        } else {
            Set<FAccessExp> res = new HashSet<FAccessExp>();
            for (FAccessExp use : uses())
                if (use.isLeftHandSide())
                    res.add(use);
            return res;
        }
    }
    
    inh boolean FExp.inFunctionCallLeft();
    eq FFunctionCallLeft.getChild().inFunctionCallLeft() = true;
    eq FClass.getChild().inFunctionCallLeft()            = false;
    eq InstRoot.getChild().inFunctionCallLeft()          = false;
    
    inh boolean FExp.isFunctionCallLeft();
    eq FFunctionCallLeft.getChild().isFunctionCallLeft() = true;
    eq FExp.getChild().isFunctionCallLeft()              = false;
    eq FClass.getChild().isFunctionCallLeft()            = false;
    eq InstRoot.getChild().isFunctionCallLeft()          = false;
    
    /**
     * Checks if this expression is used in a function call
     */
    inh boolean FExp.inFunctionCall();
    eq FFunctionCall.getChild().inFunctionCall() = true;
    eq FClass.getChild().inFunctionCall()        = false;
    eq InstRoot.getChild().inFunctionCall()      = false;
    
    inh boolean FExp.isFunctionCallArg();
    eq BaseNode.getChild().isFunctionCallArg()    = false;
    eq FFunctionCall.getArg().isFunctionCallArg() = true;
    eq FIfExp.getThenExp().isFunctionCallArg()    = isFunctionCallArg();
    eq FIfExp.getElseExp().isFunctionCallArg()    = isFunctionCallArg();

    syn boolean FExp.containsCommonFunctionCallExp() {
        for (FExp exp : childFExps()) {
            if (exp.containsCommonFunctionCallExp()) {
                return true;
            }
        }
        return false;
    }
    eq CommonFunctionCall.containsCommonFunctionCallExp() = true;

    /**
     * Returnes the function input that this expressions corresponds to.
     * NOTICE, this method will throw exception if this exp does not reside in a function call.
     */
    inh CommonVariableDecl FExp.myCorrespondingInput();
    eq FFunctionCall.getArg(int i).myCorrespondingInput()    = myFCallable().myInput(i);
    eq InstFunctionCall.getArg(int i).myCorrespondingInput() = myInstCallable().myCallInputs().get(i);
    eq FClass.getChild().myCorrespondingInput() {
        throw new UnsupportedOperationException();
    }
    eq InstRoot.getChild().myCorrespondingInput() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * Check if this is the left hand side of an equation.
     */
    inh boolean FExp.isLeftHandSide();
    eq BaseNode.getChild().isLeftHandSide()    = false;
    eq FEquation.getLeft().isLeftHandSide()    = true;
    eq FFunctionCallLeft.getChild().isLeftHandSide()  = true;
    eq FArray.getChild().isLeftHandSide()             = isLeftHandSide();
    eq FRecordConstructor.getChild().isLeftHandSide() = isLeftHandSide();
    
    /**
     * Check if this is the left hand side of an assignment or function call statement.
     */
    inh boolean FAssignableExp.isAssignedTo();
    inh boolean FFunctionCallLeft.isAssignedTo();
    eq BaseNode.getChild().isAssignedTo()         = false;
    eq FAssignStmt.getLeft().isAssignedTo()       = true;
    eq FFunctionCallStmt.getLeft().isAssignedTo() = true;
    eq FFunctionCallLeft.getFExp().isAssignedTo() = isAssignedTo();
    
    /**
     * Check if this is exp is bound in a declaration
     */
    inh boolean FExp.isBound();
    eq Root.getChild().isBound()                   = false;
    eq InstValueModification.getFExp().isBound()   = true;
    eq InstFunctionCall.getArg().isBound()        = false;
    
    inh boolean FExp.inParamBindingExp();
    eq Root.getChild().inParamBindingExp() = false;
    eq FVariable.getBindingExp().inParamBindingExp() = isParameter();
    
    inh TypePrefixVariability FExp.bindingExpVariability();
    eq Root.getChild().bindingExpVariability() = Variability.CONTINUOUS;
    eq FVariable.getChild().bindingExpVariability() = variability();
    eq FVariable.getFAttribute().bindingExpVariability() = Variability.FIXEDPARAMETER;
    eq FRecordVariable.getFAttribute(int i).bindingExpVariability() =
            variability().component(getFAttribute(i).name());
    
    /**
     * Collection attribute returning all dependent parameters which
     * depends on the parameter.
     */
    
    coll HashSet<FVariable> FAbstractVariable.dependentParameters() 
      [new LinkedHashSet<FVariable>()] 
        with addAll root FlatRoot;
    
    FAccessExp contributes boundParameters() when myFV().isParameter()
        to FAbstractVariable.dependentParameters() for myFV();
    
    syn lazy Collection<FRealVariable> FAbstractVariable.dependentRealParameters() =
            FClass.filterCollection(dependentParameters(), FClass.REAL_VARIABLE_FILTER);

    syn lazy Collection<FIntegerVariable> FAbstractVariable.dependentIntegerParameters() =
            FClass.filterCollection(dependentParameters(), FClass.INTEGER_VARIABLE_FILTER);

    syn lazy Collection<FEnumVariable> FAbstractVariable.dependentEnumParameters() =
            FClass.filterCollection(dependentParameters(), FClass.ENUM_VARIABLE_FILTER);
    
    syn lazy Collection<FBooleanVariable> FAbstractVariable.dependentBooleanParameters() =
            FClass.filterCollection(dependentParameters(), FClass.BOOLEAN_VARIABLE_FILTER);

    syn lazy Collection<FStringVariable> FAbstractVariable.dependentStringParameters() =
            FClass.filterCollection(dependentParameters(), FClass.STRING_VARIABLE_FILTER);

    /**
     * Collection attribute returning all input variables (FVariables)
     * referenced in an equation.
     */
     
    coll LinkedHashSet<FVariable> FAbstractEquation.retrieveInputs() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when 
        myFV().isFVariable() && myFV().isInput() to 
        FAbstractEquation.retrieveInputs() for myFEquation();

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.inputs() = 
        retrieveInputs();
    
    eq FIfWhenElseEquation.inputs()  {
        LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
        s.addAll(retrieveInputs());
        for (FAbstractEquation e : getFAbstractEquations()) {
            s.addAll(e.inputs());
        }
        return s;
    }
    eq FIfWhenEquation.inputs()  {
        LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
        s.addAll(super.inputs());
        if (hasElse())
            s.addAll(getElse().inputs());
        return s;
    }

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.realInputs() = 
            new LinkedHashSet<FVariable>(FClass.filterCollection(inputs(), FClass.REAL_VARIABLE_FILTER));

    
    /**
     * Collection attribute returning all algebraic variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.algebraicVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when isAlgebraicVariableAccess() to 
        FAbstractEquation.algebraicVariables() for each enclosingEquationsIterator();

    syn boolean FAccessExp.isAlgebraicVariableAccess() = inAccessLocation() && myFV().isAlgebraicVariable();

    /**
     * Returns true if this access is in a location where it should be
     * contributed to the equation system.
     */
    inh boolean FAccessExp.inAccessLocation();
    eq FlatRoot.getChild().inAccessLocation()               = false;
    eq SourceRoot.getChild().inAccessLocation()             = false;
    eq FAbstractEquation.getFAttribute().inAccessLocation() = false;
    eq FAbstractEquation.getChild().inAccessLocation()      = true;
    eq FRelExp.getIndicator().inAccessLocation()            = false;


    /**
     * Collection attribute returning all derivative variables (FDerivativeVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FDerivativeVariable> FAbstractEquation.derivativeVariables() 
        [new LinkedHashSet<FDerivativeVariable>()] with add root FAbstractEquation;

    FDerExp contributes (FDerivativeVariable) myFV() when myFV().isDerivativeVariable() && inAccessLocation() to 
        FAbstractEquation.derivativeVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all differentiated variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.differentiatedRealVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when myFV().isDifferentiatedVariable() && inAccessLocation() to 
        FAbstractEquation.differentiatedRealVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all dependent parameter variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.parameters() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when myFV().isParameter() && inAccessLocation() to 
        FAbstractEquation.parameters() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all discrete variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.discreteVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when myFV().isDiscreteVariable() && inAccessLocation() to 
        FAbstractEquation.discreteVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all non-fixed parameters (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.initialParameters()
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FAccessExp contributes (FVariable) myFV() when myFV().isInitialParameter() && inAccessLocation() to
        FAbstractEquation.initialParameters() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all pre variables (FPreVariable)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.discretePreVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FPreExp contributes (FVariable) myFV() when myFV().isPreVariable() && inAccessLocation() to 
        FAbstractEquation.discretePreVariables() for each enclosingEquationsIterator();

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.variables() {
        LinkedHashSet<FVariable> l = new LinkedHashSet<FVariable>();
        l.addAll(differentiatedRealVariables());
        l.addAll(derivativeVariables());
        l.addAll(algebraicVariables());
        l.addAll(discreteVariables());
        return l;
    }

    /**
     * Returns the event indicators for the expressions that are found by {@link #relExpInEquation}.
     */
    syn Set<FVariable> FAbstractEquation.eventIndicators() {
        Set<EventGeneratingExp> exps = new HashSet<>();
        exps.addAll(relExpInEquation());
        exps.addAll(delayExpInEquation());
        exps.addAll(spatialDistExpInEquation());
        
        Set<FVariable> res = new HashSet<>();
        for (EventGeneratingExp exp : exps) {
            if (exp.hasIndicator()) {
                res.addAll(exp.myIndicatorVariables());
            }
        }
        return res;
    }

    /**
     * Returns all variables known to this equation that are part of the
     * equation system, e.g. variables in the attributes isn't included in this
     * list.
     * <p>
     * Word of causion, this method is used for debug output right now and I
     * got a feeling that it might return the same variable twice! So test well
     * if you're going to use it "for real".
     */
    syn Iterable<FVariable> FAbstractEquation.allVariables() {
        return new ChainedIterable<FVariable>(variables(), discretePreVariables(), parameters());
    }

    /**
     * Get the differenetiated variabel (FVariable) corresponding to 
     * a derivative variable (FDerivativeVariable)
     */
    syn FAbstractVariable FVariable.myDifferentiatedVariable() {
        if (order() <= 0) {
            return unknownFVariable();
        } else if (order() == 1) {
            return getFAccess().myFV();
        } else {
            return getFAccess().myDerFV(order() - 1);
        }
    }

    /**
     * Get the derivative variabel (FDerivativeVariable) corresponding to 
     * a differentiated variable (FVariable)
     */
    syn FAbstractVariable FVariable.myDerivativeVariable() = getFAccess().myDerFV(order() + 1);

    /**
     * Get the pre variable connected to a normal variable, if any.
     */
    syn FAbstractVariable FAbstractVariable.myPreVariable() = getFAccess().myPreFV();
    
    /**
     * Get the normal variable connected to a pre variable.
     * 
     * Will be unknown for non-pre variables.
     */
    syn FAbstractVariable FAbstractVariable.myNonPreVariable() = getFAccess().myFV();
}

aspect LinearFVariables {
    
    /**
     * Check linearity of variable.
     * 
     * The attribute isLinear returns true if all uses of the variable appears
     * linearly in equations and in initial equations. Parameters and constants
     * are assumed to be literals in the linearity computation. Accordingly,
     * multiplication of a variable with a parameter or constant does not render
     * the variable nonlinear. Also, parameters and constants are considered
     * to be linear themselves.
     */
    syn lazy boolean FVariable.isLinear() {
        if (isParameter() || isConstant()) {
            return true;
        }
        for (FAccessExp e : uses()) {
            if (!e.isLinear()) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Check if a subexpression appears linearly.
     * 
     * Note that this method does not check if the expression itself is linear
     * but wheather it apperas linearly in a composite expression. For example
     * the sub expression 'sin(x)' appears linearly in '1+sin(x)'.
     */
    inh boolean FExp.isLinear();
    eq FlatRoot.getChild().isLinear() = true;
    eq SourceRoot.getChild().isLinear() = true;
    
    eq FAbstractEquation.getChild().isLinear() = true;
    
    eq FDotMulExp.getLeft().isLinear() =
        (getRight().isConstantExp() || getRight().isLinearParameterExp())?
                isLinear() : false;
    eq FDotMulExp.getRight().isLinear() =
        (getLeft().isConstantExp() || getLeft().isLinearParameterExp())?
                isLinear() : false;
    eq FDotDivExp.getLeft().isLinear() =
        (getRight().isConstantExp() || getRight().isLinearParameterExp())?
                isLinear() : false;
    eq FDotDivExp.getRight().isLinear() = false;
    eq FDotPowExp.getChild().isLinear() = false;
    eq FFunctionCall.getChild().isLinear() = false;
    eq FMathematicalFunctionCall.getChild().isLinear() = false;
                
    // This definition is to avoid errors when isParameterExp is redefined
    // to include free parameters in the Optimica extension.
    syn boolean FExp.isLinearParameterExp() = isParameterExp();
    
    syn boolean FAbstractEquation.checkLinearity(Set<FVariable> vars) {
        for (FAccessExp e : referencedCommonAccessExps()) {
            if (vars.contains(e.myFV()) && !e.isLinear(vars)) {
                return false;
            }
        }
        return true;
    }
    eq FIfWhenElseEquation.checkLinearity(Set<FVariable> vars) = false;
    eq FAlgorithm.checkLinearity(Set<FVariable> vars) = false;
    
    inh boolean FExp.isLinear(Set<FVariable> vars);
    eq FlatRoot.getChild().isLinear(Set<FVariable> vars)   = true;
    eq SourceRoot.getChild().isLinear(Set<FVariable> vars) = true;
    
    eq FAbstractEquation.getChild().isLinear(Set<FVariable> vars) = true;
    eq FStatement.getChild().isLinear(Set<FVariable> vars)        = false;
    
    eq FDotMulExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);
    eq FDotMulExp.getRight().isLinear(Set<FVariable> vars) = getLeft().isIndependent(vars) && isLinear(vars);
    eq FDotDivExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);
    eq FDotDivExp.getRight().isLinear(Set<FVariable> vars) = false;
    eq FDotPowExp.getChild().isLinear(Set<FVariable> vars) = false;
    eq FFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FMathematicalFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FAbstractFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FIfExp.getIfExp().isLinear(Set<FVariable> vars) = !isWhen() && (!inNoEventExp() || getIfExp().isIndependent(vars)); 
    eq FNoEventExp.getFExp().isLinear(Set<FVariable> vars) = isLinear(vars);
    
    syn boolean FExp.isIndependent(Set<? extends CommonVariableDecl> set) {
        for (FExp e : childFExps()) {
            if (!e.isIndependent(set)) {
                return false;
            }
        }
        return true;
    }

    syn boolean FIfExp.isIndependent(Set<? extends CommonVariableDecl> set) {
        // Don't check the guard exp since it is discrete and does not affect
        // linearity.
        return getThenExp().isIndependent(set) && getElseExp().isIndependent(set);
    }

    eq FAbstractDerExp.isIndependent(Set<? extends CommonVariableDecl> set) {
        return !set.contains(myFV());
    }

    eq FAccessExp.isIndependent(Set<? extends CommonVariableDecl> set) {
        return getFAccess().isIndependent(set);
    }

    syn boolean CommonAccess.isIndependent(Set<? extends CommonVariableDecl> set);
    
    eq FAccess.isIndependent(Set<? extends CommonVariableDecl> set) {
        return !set.contains(myFV());
    }

    eq InstAccess.isIndependent(Set<? extends CommonVariableDecl> set) {
        return !set.contains(myInstComponentDecl());
    }

}

aspect FlatDiagnostics {

    syn String FClass.diagnostics() {
        StringBuilder str = new StringBuilder();
        str.append("Diagnostics for flattened class " + name() + "\n");

        str.append(modelDiagnostics());
        
        str.append("\n");
        
        str.append(variableDiagnostics());
        
        str.append("\n");  

        str.append(aliasDiagnostics());
        
        str.append("\n");  
        
        str.append(incidence());

        str.append("\n");  
        
        str.append(dependencyDiagnostics());

        str.append("\n");
        
//      str.append(dersAndDiffs());
        
        str.append("\n");  
        
        str.append(connectionSetDiagnostics());
        
        return str.toString();
    }

    public String FClass.modelDiagnostics() {
        StringBuilder str = new StringBuilder();
        modelDiagnosticsPrintRow(str, "Number of independent constants:", independentConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real independent constants:", independentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real independent constants:", independentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Integer independent constants:", independentIntegerConstants());
        modelDiagnosticsPrintRow(str, "  Number of Enum independent constants:", independentEnumConstants());
        modelDiagnosticsPrintRow(str, "  Number of Boolean independent constants:", independentBooleanConstants());
        modelDiagnosticsPrintRow(str, "  Number of String independent constants:", independentStringConstants());

        modelDiagnosticsPrintRow(str, "Number of dependent constants:", dependentConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real dependent constants:", dependentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Integer dependent constants:", dependentIntegerConstants());
        modelDiagnosticsPrintRow(str, "  Number of Enum dependent constants:", dependentEnumConstants());
        modelDiagnosticsPrintRow(str, "  Number of Boolean dependent constants:", dependentBooleanConstants());
        modelDiagnosticsPrintRow(str, "  Number of String dependent constants:", dependentStringConstants());

        modelDiagnosticsPrintRow(str, "Number of independent parameters:", independentParameters());
        modelDiagnosticsPrintRow(str, "  Number of Real independent parameters:", independentRealParameters());
        modelDiagnosticsPrintRow(str, "  Number of Integer independent parameters:", independentIntegerParameters());
        modelDiagnosticsPrintRow(str, "  Number of Enum independent parameters:", independentEnumParameters());
        modelDiagnosticsPrintRow(str, "  Number of Boolean independent parameters:", independentBooleanParameters());
        modelDiagnosticsPrintRow(str, "  Number of String independent parameters:", independentStringParameters());
                  
        modelDiagnosticsPrintRow(str, "Number of dependent parameters:", dependentParameters());
        modelDiagnosticsPrintRow(str, "  Number of Real dependent parameters:", dependentRealParameters());
        modelDiagnosticsPrintRow(str, "  Number of Integer dependent parameters:", dependentIntegerParameters());
        modelDiagnosticsPrintRow(str, "  Number of Enum dependent parameters:", dependentEnumParameters());
        modelDiagnosticsPrintRow(str, "  Number of Boolean dependent parameters:", dependentBooleanParameters());
        modelDiagnosticsPrintRow(str, "  Number of String dependent parameters:", dependentStringParameters());
        
        modelDiagnosticsPrintRow(str, "Number of initial parameters:", initialParameters());
        modelDiagnosticsPrintRow(str, "  Number of Real dependent parameters:", realInitialParameters());
        modelDiagnosticsPrintRow(str, "  Number of Integer dependent parameters:", integerInitialParameters());
        modelDiagnosticsPrintRow(str, "  Number of Enum dependent parameters:", enumInitialParameters());
        modelDiagnosticsPrintRow(str, "  Number of Boolean dependent parameters:", booleanInitialParameters());
        modelDiagnosticsPrintRow(str, "  Number of String dependent parameters:", stringInitialParameters());
        
        modelDiagnosticsPrintRow(str, "Number of variables:", variables());
        modelDiagnosticsPrintRow(str, "  Number of Real variables:", realVariables());
        modelDiagnosticsPrintRow(str, "  Number of Integer variables:", integerVariables());
        modelDiagnosticsPrintRow(str, "  Number of Enum variables:", enumVariables());
        modelDiagnosticsPrintRow(str, "  Number of Boolean variables:", booleanVariables());
        modelDiagnosticsPrintRow(str, "  Number of String variables:", stringVariables());

        modelDiagnosticsPrintRow(str, "Number of Real differentiated variables:", differentiatedRealVariables()); 
        modelDiagnosticsPrintRow(str, "Number of Real derivative variables:", derivativeVariables()); 
        modelDiagnosticsPrintRow(str, "Number of Real continous algebraic variables:", algebraicContinousRealVariables());

        modelDiagnosticsPrintRow(str, "Number of inputs:", inputs());
        modelDiagnosticsPrintRow(str, "  Number of Real inputs:", realInputs());
        modelDiagnosticsPrintRow(str, "  Number of Integer inputs:", integerInputs());
        modelDiagnosticsPrintRow(str, "  Number of Enum inputs:", enumInputs());
        modelDiagnosticsPrintRow(str, "  Number of Boolean inputs:", booleanInputs());
        modelDiagnosticsPrintRow(str, "  Number of String inputs:", stringInputs());
        
        modelDiagnosticsPrintRow(str, "Number of discrete variables:", discreteVariables());
        modelDiagnosticsPrintRow(str, "  Number of Real discrete variables:", discreteRealVariables());
        modelDiagnosticsPrintRow(str, "  Number of Integer discrete variables:", discreteIntegerVariables());
        modelDiagnosticsPrintRow(str, "  Number of Enum discrete variables:", discreteEnumVariables());
        modelDiagnosticsPrintRow(str, "  Number of Boolean discrete variables:", discreteBooleanVariables());
        modelDiagnosticsPrintRow(str, "  Number of String discrete variables:", discreteStringVariables());
        
        modelDiagnosticsPrintRow(str, "Number of equations:", equations());
        
        modelDiagnosticsPrintRow(str, "Number of variables with binding expression:", variablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Real variables with binding exp:", realVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Integer variables binding exp:", integerVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Enum variables binding exp:", enumVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Boolean variables binding exp:", booleanVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of String variables binding exp:", stringVariablesWithBindingExp());
            
        modelDiagnosticsPrintRow(str, "Total number of equations:", equations(), variablesWithBindingExp());
    
        modelDiagnosticsPrintRow(str, "Number of initial equations:", initialEquations());

        str.append(String.format("Number of event indicators in equations:      %6d\n", numEventIndicators()));
        str.append(String.format("Number of event indicators in init equations: %6d\n", numRelExpInInitialEquations()));


        return str.toString();
    }
    
    private static void FClass.modelDiagnosticsPrintRow(StringBuilder sb, String label, Collection<? extends FDiagnosticsNode> ... lists) {
        int num = 0;
        int numScalar = 0;
        for (Collection<? extends FDiagnosticsNode> list : lists) {
            num += list.size();
            numScalar += countNumScalars(list);
        }
        sb.append(String.format("%-46s%6d(%5d scalars)\n", label, num, numScalar));
    }

    private static int FClass.countNumScalars(Collection<? extends FDiagnosticsNode> nodes) {
        int num = 0;
        for (FDiagnosticsNode node : nodes)
            num += node.numScalars();
        return num;
    }

    public interface FDiagnosticsNode {
        public int numScalars();
    }
    public class FAbstractEquation implements FDiagnosticsNode {}
    public class FVariable implements FDiagnosticsNode {}
    
    syn int FAbstractEquation.numScalars() = numScalarEquations();
    syn int FVariable.numScalars() = type().numScalarElements();
    
    public String FClass.aliasDiagnostics() {
        StringBuilder str = new StringBuilder();
        str.append("Alias sets:\n");
        if (getAliasManager()!=null) {
            str.append(getAliasManager());
            int n_elim = 0;
            for (AliasManager.AliasSet aliasSet : getAliasManager().getAliasSets()) {
                n_elim += aliasSet.numAliases() - 1;
            }
            str.append(n_elim + " variables can be eliminated\n");
                
        } else {
            str.append("  Alias sets not computed.\n");
        }
        return str.toString();  
        
    }

    public String FClass.aliasDiagnosticsShort() {
        StringBuilder str = new StringBuilder();
        if (getAliasManager()!=null) {
            int n_elim = 0;
            Set<AliasManager.AliasSet> aliasSets = getAliasManager().getAliasSets();
            for (AliasManager.AliasSet aliasSet : aliasSets) {
                n_elim += aliasSet.numAliases() - 1;
            }
            str.append(aliasSets.size());
            str.append(" sets, ");
            str.append(n_elim);
            str.append(" eliminated variables");
        } else {
            str.append("Alias sets not computed");
        }
        return str.toString();  
        
    }

    public String FClass.variableDiagnostics() {
        
        StringBuilder str = new StringBuilder();
        
        str.append("Independent constants: \n");
        for (FVariable fv : independentConstants()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");
        
        str.append("Dependent constants: \n");
        for (FVariable fv : dependentConstants()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");
        
        str.append("Independent parameters: \n");
        for (FVariable fv : independentParameters()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            if (fv.hasBindingExp()) {
                CValue val = CValue.UNKNOWN;
                try {
                    val = fv.getBindingExp().ceval();
                } catch (ConstantEvaluationException e) {
                    
                }
                str.append(", evaluated binding exp: ");
                str.append(val);
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Dependent parameters: \n");
        for (FVariable fv : dependentParameters()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }

        str.append("\n");  
        str.append("Differentiated variables: \n");
        for (FVariable fv : differentiatedRealVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append("\n");
        }

        str.append("\n");  
        str.append("Derivative variables: \n");
        for (FVariable fv : derivativeVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");  

        str.append("Discrete variables: \n");
        for (FVariable fv : discreteVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append(", alias: ");
            if (!fv.isAlias()) {
                str.append("no");
            } else {
                if (fv.isNegated()) {
                    str.append("-");
                }
                str.append(fv.alias().valueReference());
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Algebraic real variables: \n");
        for (FVariable fv : algebraicContinousRealVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append(", alias: ");
            if (!fv.isAlias()) {
                str.append("no");
            } else {
                if (fv.isNegated()) {
                    str.append("-");
                }
                str.append(fv.alias().valueReference());
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Input variables: \n");
        for (FVariable fv : inputs()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }

        return str.toString();
        
    }

    public String FClass.dependencyDiagnostics() {
        
        StringBuilder str = new StringBuilder();
            
        if (myOptions().getBooleanOption("equation_sorting")) {
            
            str.append("Variable dependencies:\n");
            
            if (getNumFVariable() > myOptions().getIntegerOption("diagnostics_limit")) {
                str.append("Oh dear, the model has way to many variables (" + getNumFVariable() + ")!\n");
                str.append("Current limit is set to " + myOptions().getIntegerOption("diagnostics_limit") + ", you can change this by changing the option 'diagnostics_limit'.\n");
                return str.toString();
            }
            
            str.append("Derivative variables: \n");
            for (FVariable fv : derivativeVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
            str.append("Differentiated variables: \n");
            for (FVariable fv : differentiatedRealVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
            str.append("Algebraic real variables: \n");
            for (FVariable fv : algebraicContinousRealVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
        }
        return str.toString();
    }
    
    public String FClass.directDependencyDiagnostics() {
        StringBuilder sb = new StringBuilder();
        for (FVariable output : realOutputs()) {
            sb.append(output.name());
            sb.append("\n");
            for (FVariable input : output.directDependencies()) {
                sb.append("    ");
                sb.append(input.name());
                sb.append("\n");
            }
        }
        return sb.toString();
    }    
    
    public Set<FVariable> FVariable.directDependencies() {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FVariable dv : dependsOn()) {
            if (dv.isInput()) {
                res.add(dv);
            }
        }
        return res;
    }

    public String FClass.connectionSetDiagnostics() {
        return getConnectionSetManager().printConnectionSets();
    }
    
    public String FClass.incidence() {
        return incidence(false);
    }

    public String FClass.incidence(boolean printAllVariables) {
        StringBuilder str = new StringBuilder();
        
        str.append("Incidence:\n");
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            Iterable<? extends FVariable> vars;
            if (printAllVariables) {
                vars = fe.allVariables();
            } else {
                vars = new ChainedIterable<FVariable>(fe.derivativeVariables(), fe.algebraicVariables());
            }
            str.append(" eq " + i + ":");
            for (FVariable var : vars) {
                str.append(" " + var.name());
            }
            str.append("\n");
            i++;
        }
        
        return str.toString();
    }
    
    public String FClass.dersAndDiffs() {
        StringBuilder str = new StringBuilder();
        str.append("Derivatives and differentiated variables:\n");
        for (FDerivativeVariable fdv : derivativeVariables()) {
            if (fdv.myDifferentiatedVariable()!=null) {
                str.append(" " + fdv.name() + ", " + fdv.myDifferentiatedVariable().name() + "\n");
            }
        }   
        str.append("Differentiated variables and derivatives:\n");
        for (FVariable fv : differentiatedRealVariables()) {
            if (fv.myDerivativeVariable()!=null) {
                str.append(" " + fv.name() + ", " + fv.myDerivativeVariable().name() + "\n");
            }
        }
        return str.toString();
        
    }
    
    public String FClass.printDAEBLT() {
        return getDAEBLT() == null ? "" : getDAEBLT().toString();
    }

    public String FClass.printDAEInitBLT() {
        return getDAEInitBLT().toString();
    }
    
    public String FClass.printMatchedDAE() {
        return computeMatchedDAEBiPGraph(createBLTInput()).toString();
    }


    syn String FClass.attributeLevels() {
        StringBuilder str = new StringBuilder();
        str.append("Variables:\n");
        for (FVariable v : getFVariables())
            v.attributeLevels(str);
        for (FVariable v : getAliasVariables())
            v.attributeLevels(str);
        if (getNumFDerivedType() > 0) {
            str.append("\nTypes:\n");
            for (FDerivedType t : getFDerivedTypes())
                t.attributeLevels(str);
        }
        return str.toString();
    }

    public void FVariable.attributeLevels(StringBuilder str) {
        str.append("  ");
        str.append(name());
        attributeLevelsForList(getFAttributes(), str);
        str.append("\n");
    }

    public void FDerivedType.attributeLevels(StringBuilder str) {
        str.append("  ");
        str.append(getName());
        attributeLevelsForList(getFAttributes(), str);
        str.append("\n");
    }

    public void FAttribute.attributeLevels(StringBuilder str) {
        str.append(name());
        str.append(":");
        str.append(getLevel());
        attributeLevelsForList(getFAttributes(), str);
        if (hasValue()) {
            str.append("=");
            str.append(getValue());
        }
    }

    public static void ASTNode.attributeLevelsForList(List<FAttribute> l, StringBuilder str) {
        if (l.getNumChild() > 0) {
            str.append("(");
            String sep = ", ";
            String pref = "";
            for (FAttribute a : l) {
                str.append(pref);
                a.attributeLevels(str);
                pref = sep;
            }
            str.append(")");
        }
    }

}

aspect FlatAlgorithmAPI {
    
    syn boolean FExp.inFAlgorithm() = myFAlgorithm() != null;
    
    syn FAlgorithm FAccessExp.myFAlgorithm() = getFAccess().myFAlgorithm();
    inh lazy FAlgorithm CommonAccess.myFAlgorithm();
    inh lazy FAlgorithm FStatement.myFAlgorithm();
    inh FAlgorithm FExp.myFAlgorithm();
    eq FAbstractEquation.getChild().myFAlgorithm() = null;
    eq FAlgorithm.getChild().myFAlgorithm() = this;
    eq Root.getChild().myFAlgorithm() = null;
    
    coll ArrayList<FAlgorithm> FClass.myAlgorithms()
        [new ArrayList<FAlgorithm>()] with add root FClass;
    FAlgorithm contributes this when !inFunction()
        to FClass.myAlgorithms() for myFClass();
    
    inh boolean CommonAccess.useIsAssignment();
    inh boolean FAssignableExp.useIsAssignment();
    inh boolean FArray.useIsAssignment();
    inh boolean FRecordConstructor.useIsAssignment();
    eq FAssignStmt.getLeft().useIsAssignment()       = true;
    eq FFunctionCallLeft.getFExp().useIsAssignment() = true;
    eq FAssignableExp.getChild().useIsAssignment()   = useIsAssignment();
    eq FArraySubscripts.getChild().useIsAssignment() = false;
    eq FArray.getFExp().useIsAssignment()            = useIsAssignment();
    eq FRecordConstructor.getArg().useIsAssignment() = useIsAssignment();
    eq FExp.getChild().useIsAssignment()             = false;
    eq FStatement.getChild().useIsAssignment()       = false;
    eq FAlgorithm.getChild().useIsAssignment()       = false;
    eq Root.getChild().useIsAssignment()             = false;
    
    private String FAlgorithm.functionName = null;
    public String FAlgorithm.generateFunctionName() {
        if (functionName == null)
            functionName = myFClass().generateFunctionName();
        return functionName;
    }
    private int FClass.generatedFunctionNumber = 1;
    public String FClass.generateFunctionName() {
        String name, part;
        do {
            part = "algorithm_" + generatedFunctionNumber;
            name = name() + "." + part;
            generatedFunctionNumber++;
        } while (lookupFunc(name) != null || variablesMap().lookup(part) != null);
        return name;
    }
    
}

aspect FlatExternalFunctionAPI {
    
    /**
     * Gives the arguments to pass to gcc required by external functions.
     */
    syn String FClass.externalCompilerArgs() {
        StringBuilder buf = new StringBuilder();
        for (String lib : externalLibraries()) {
            buf.append(" -l");
            buf.append(lib);
        }
        for (String dir : externalLibraryDirectories()) {
            buf.append(" -L");
            buf.append(dir);
        }
        for (String dir : externalIncludeDirectories()) {
            buf.append(" -I");
            buf.append(dir);
        }
        return buf.toString();
    }

    syn String FClass.externalLibArgs() {
        StringBuilder buf = new StringBuilder();
        for (String lib : externalLibraries()) {
            buf.append(" -l");
            buf.append(lib);
        }
        for (String dir : externalLibraryDirectories()) {
            buf.append(" -L");
            buf.append(dir);
        }
        return buf.toString();
    }

    syn String FClass.externalIncludeArgs() {
        StringBuilder buf = new StringBuilder();
        for (String dir : externalIncludeDirectories()) {
            buf.append(" -I");
            buf.append(dir);
        }
        return buf.toString();
    }
    
    coll HashSet<FExternalStmt> FClass.myExternals()
        [new LinkedHashSet<FExternalStmt>()] with add root FClass;
    FExternalStmt contributes this
        to FClass.myExternals() for myFClass();
    
    syn HashSet<String> FClass.externalLibraries() {
        HashSet<String> res = new LinkedHashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.library() != null)
                for (String lib : ext.library())
                    res.add(lib);
        return res;
    }
    
    syn HashSet<String> FClass.externalIncludes() {
        HashSet<String> res = new LinkedHashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.include() != null)
                res.add(ext.include());
        return res;
    }
    
    syn HashSet<String> FClass.externalLibraryDirectories() {
        HashSet<String> res = new LinkedHashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.libraryDirectory() != null)
                res.add(ext.libraryDirectory());
        return res;
    }
    
    syn HashSet<String> FClass.externalIncludeDirectories() {
        HashSet<String> res = new LinkedHashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.includeDirectory() != null)
                res.add(ext.includeDirectory());
        return res;
    }
    
    syn String[] FExternalStmt.library() = library;
    syn String FExternalStmt.include()            = include;
    syn String FExternalStmt.libraryDirectory()   = libraryDir;
    syn String FExternalStmt.includeDirectory()   = includeDir;
    syn boolean FExternalStmt.isIncluded() = !(include() == null || include().equals(""));
    syn boolean FExternalStmt.isInLibrary() = !(libraryDirectory() == null || libraryDirectory().equals(""));
    
    private String[] FExternalStmt.library;
    private String FExternalStmt.include;
    private String FExternalStmt.libraryDir;
    private String FExternalStmt.includeDir;
    
    public void FExternalStmt.extractLibrary(FExternalStmt n) {
        this.library = n.library;
        this.include = n.include;
        this.libraryDir = n.libraryDir;
        this.includeDir = n.includeDir;
    }
    
    public void FExternalStmt.extractLibrary(InstExternal n) {
        library = n.annotation("Library").asStringVector();
        include = n.annotation("Include").string();
        libraryDir = n.annotation("LibraryDirectory").string();
        includeDir = n.annotation("IncludeDirectory").string();
        
        if (libraryDir == null || includeDir == null) {
            String libraryName = n.libraryName();
            if (libraryName != null) {
                String defDir = "modelica://" + libraryName + "/Resources";
                libraryDir = (libraryDir == null && library != null) ? 
                        defDir + "/Library" : libraryDir;
                includeDir = (includeDir == null && include != null) ? 
                        defDir + "/Include" : includeDir;
            }
        }
        
        if (includeDir != null) 
            includeDir = URIResolver.DEFAULT.resolve(n, includeDir);
        if (libraryDir != null) {
            libraryDir = URIResolver.DEFAULT.resolve(n, libraryDir);
        }
    }

}

aspect ExpressionGeneralisation {
    /**
     * Returns the expression stripped of any negations
     */
    syn FExp FExp.stripNegations()     = this;
    eq FNegExp.stripNegations()        = getFExp().stripNegations();
    
    
    syn boolean FEquation.isNegated() = getLeft().isNegated() ^ getRight().isNegated();
    
    /**
     * Check if the expressions is negated
     */
    syn boolean FExp.isNegated()  = false;
    eq FNegExp.isNegated()        = !getFExp().isNegated();
    
    /**
     * Return this expression negated if <code>neg</code> is true.
     */
    syn FExp FExp.negated(boolean neg) {
        if (neg)
            return new FNegExp(unboundCopy());
        else
            return unboundCopy();
    }
}
