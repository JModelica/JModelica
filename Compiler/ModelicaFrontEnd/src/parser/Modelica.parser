/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%goal source_root;
%goal anonymous_short_class;
%goal exp;
%goal element;
%goal abstract_equation;
%goal argument;
%goal access_scalar;

%header {:
 package $PARSER_PACKAGE$;
 import $AST_PACKAGE$.*;
 import org.jmodelica.util.AdjustableSymbol;
 import org.jmodelica.util.AbstractAdjustableSymbol;
 import org.jmodelica.util.formatting.FormattingRecorder;
 import org.jmodelica.util.formatting.FormattingType;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
:};

%embed {:

    /**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.getId() == Terminals.EOF) {
                s.append("  Unexpected end of file");
            } else if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC,
                    Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()),
                    Symbol.getLine(token.getEnd()), Symbol.getColumn(token.getEnd()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL,
                    e.line, e.column, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link java.util.Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingRecorder<ASTNode<?>> formattingRecorder;

    public void setFormattingRecorder(FormattingRecorder<ASTNode<?>> formattingRecorder) {
        this.formattingRecorder = formattingRecorder;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    private LoadInfo loadInfo;
    
    public void setLoadInfo(LoadInfo loadInfo) {
        this.loadInfo = loadInfo;
    }
    
    public LoadInfo getLoadInfo() {
        return loadInfo;
    }
    
    Symbol annotationTok = null;
    
    private void adjustStart(Symbol... syms) {
        AdjustableSymbol[] aSyms = new AdjustableSymbol[syms.length];
        for (int i = 0; i < syms.length; i++) {
            /* All symbols involved implements AdjustableSymbol, but since we can't change 
             * Beaver, the Java compiler can't verify that. If any Symbol used doesn't then
             * we want to know that - thus the raw cast. */
            aSyms[i] = (AdjustableSymbol) syms[i];
        }
        if (aSyms.length > 0) {
            aSyms[0].adjustStartOfEmptySymbols(aSyms, 1, 0);
        }
    }
    
    private static class Bool extends AbstractAdjustableSymbol {
        public final boolean value;
        
        public Bool(boolean val) {
            value = val;
        }
    }
    
    private static Bool newTrue() {
        return new Bool(true);
    }
    
    private static Bool newFalse() {
        return new Bool(false);
    }
    
    private static class RedeclareReplaceableHeader extends AbstractAdjustableSymbol {
        public final boolean has_redeclare;
        public final boolean has_each;
        public final boolean has_final;
        
        public RedeclareReplaceableHeader(boolean has_redeclare,
                                          boolean has_each,
                                          boolean has_final) {
            this.has_redeclare = has_redeclare;
            this.has_each = has_each;
            this.has_final = has_final;
        }
    }
    
    private static class TypePrefixes extends AbstractAdjustableSymbol {
        public final Opt<SrcTypePrefixFlow> flow;
        public final Opt<SrcTypePrefixVariability> variability;
        public final Opt<SrcTypePrefixInputOutput> input_output;
        
        public TypePrefixes(Opt<SrcTypePrefixFlow> flow, 
                            Opt<SrcTypePrefixVariability> variability, 
                            Opt<SrcTypePrefixInputOutput> input_output) {
            super(flow, variability, input_output);
            this.flow = flow;
            this.variability = variability;
            this.input_output = input_output;
        }
    }
    
    private static class ConstrClauseAndComment extends AbstractAdjustableSymbol {
        public final Opt<SrcConstrainingClause> constr;
        public final SrcComment comment;
        
        public ConstrClauseAndComment(SrcConstrainingClause constr, 
                                      SrcComment comment) {
            super(constr, comment);
            this.constr = new Opt(constr);
            this.comment = comment;
        }
        
        public ConstrClauseAndComment() {
            this.constr = new Opt();
            this.comment = new SrcComment();
        }
    }
:};
 
SourceRoot source_root
    = /* blank */ 
    {: 
        SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr; 
    :}
    | program 
    {: 
       SourceRoot sr = new SourceRoot(program); 
       return sr; 
    :};

Program program
    = stored_definition 
    {: 
        return new Program(new List().add(stored_definition)); 
    :};
  
SrcStoredDefinition stored_definition
    = within? base_class_decl_list 
    {:
        SrcStoredDefinition def = new SrcStoredDefinition(within, base_class_decl_list, getLoadInfo());
        def.setLineBreakMap(lineBreakMap);
        formattingRecorder.postParsing(def);
        return def; 
    :}
    | error 
    {: 
        return new SrcBadDefinition(); 
    :};

SrcWithin within
    = WITHIN access? SEMICOLON 
    {: 
        return new SrcWithin(access); 
    :};
  
List base_class_decl_list
    = base_class_decl SEMICOLON 
    {: 
        return new List().add(base_class_decl); 
    :}
    | base_class_decl_list base_class_decl SEMICOLON 
    {: 
        base_class_decl_list.add(base_class_decl);
        return base_class_decl_list; 
    :};

SrcBaseClassDecl anonymous_short_class 
    = extends_clause_short_class
    {:
        return new SrcShortClassDecl(
            new SrcIdDecl("'Anonymous Class'"),
            false, false, 
            new SrcClass(), 
            false, false, false, false, false, 
            new Opt(), new Opt(), 
            extends_clause_short_class); 
    :};

SrcBaseClassDecl base_class_decl 
    = has_encapsulated 
      has_partial 
      restriction  
      id_decl.start 
      string_comment? 
      clause_star
      external_clause?
      class_annotation?
      end_decl
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcFullClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl); 
    :}
    | has_encapsulated 
      has_partial 
      restriction  
      id_decl.class_name EQUALS
      extends_clause_short_class 
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcShortClassDecl(
            class_name, 
            has_encapsulated.value, 
            has_partial.value, 
            restriction, 
            false, false, false, false, false, 
            new Opt(), new Opt(),
            extends_clause_short_class);
    :}
    | has_encapsulated 
      has_partial 
      restriction 
      EXTENDS 
      id_decl.start 
      class_modification?
      string_comment? 
      clause_star
      external_clause?
      class_annotation?
      end_decl 
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        SrcInlineExtendsClause ext = new SrcInlineExtendsClause(
            new SrcNamedAccess(start.getID()),
            class_modification,
            new Opt());
        return new SrcExtendClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl, 
            ext); 
    :}
    | has_encapsulated
      has_partial
      restriction
      id_decl.enum_name
      EQUALS
      ENUMERATION
      LPAREN
      enum_specification
      RPAREN
      comment
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcEnumClassDecl(
            enum_name,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            comment.getSrcStringCommentOpt(),
            new List(new SrcDefaultElementList(new List(enum_specification))),
            new Opt(),
            comment.getSrcAnnotationOpt(),
            new SrcEndDecl(enum_name.getID()));
    :}
    | error 
    {: 
        return new SrcBadClassDecl();
    :};

SrcExtendsClauseShortClass extends_clause_short_class
    = type_prefixes
      access_scalar
      array_subscripts?
      class_modification?
      comment 
    {:
        adjustStart(type_prefixes, access_scalar);
        return new SrcExtendsClauseShortClass(
            access_scalar,
            class_modification, 
            new Opt<SrcAnnotation>(),
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            array_subscripts, 
            comment);
    :}
    ;

SrcEnumComponentClause enum_specification
    = enum_contents
    {:
        return new SrcEnumComponentClause(
                false, false, false, false, false,
                new Opt(),
                new Opt(new SrcConstant()),
                new Opt(),
                new SrcNamedAccess("EnumType"),
                new Opt(),
                enum_contents,
                new Opt(),
                new SrcComment());
    :}
    ;

List enum_contents
    = COLON                {: return new List(); :}
    | enum_literal_list    {: return enum_literal_list; :}
    ;
  
List enum_literal_list
    = enum_literal
    {:
        return new List(enum_literal);
    :}
    | enum_literal_list
      COMMA
      enum_literal
    {:
        enum_literal_list.add(enum_literal); 
        return enum_literal_list;
    :}
    ;

SrcEnumLiteralDecl enum_literal
    = id_decl
      comment
    {:
        return new SrcEnumLiteralDecl(
                id_decl,
                new Opt(),
                new Opt(),
                new Opt(),
                comment);
    :}
    ;

SrcTypePrefixFlow type_prefix_flow 
    = FLOW      {: return new SrcFlow();   :}
    | STREAM    {: return new SrcStream(); :}
    ;

SrcTypePrefixVariability type_prefix_variability 
    = DISCRETE    {: return new SrcDiscrete();  :}
    | PARAMETER   {: return new SrcParameter(); :}
    | CONSTANT    {: return new SrcConstant();  :}
    ;

SrcTypePrefixInputOutput type_prefix_input_output
    = INPUT     {: return new SrcInput();  :}
    | OUTPUT    {: return new SrcOutput(); :}
    ;

TypePrefixes type_prefixes 
    = type_prefix_flow?
      type_prefix_variability?
      type_prefix_input_output?
    {:
        adjustStart(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
        return new TypePrefixes(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
    :}
    ;


SrcRestriction restriction
    = CLASS                   {: return new SrcClass();              :}
    | MODEL                   {: return new SrcModel();               :}
    | BLOCK                   {: return new SrcBlock();               :}
    | CONNECTOR               {: return new SrcConnector();           :}
    | EXPANDABLE CONNECTOR    {: return new SrcExpandableConnector(); :}
    | TYPE                    {: return new SrcType();               :}
    | PACKAGE                 {: return new SrcPackage();            :}
    | FUNCTION                {: return new SrcFunction();            :}
    | RECORD                  {: return new SrcRecord();              :}
    | OPERATOR RECORD         {: return new SrcOperatorRecord();      :}
    | OPERATOR FUNCTION       {: return new SrcOperatorFunction();    :}
    | OPERATOR                {: return new SrcOperator();            :}
    ;

Bool has_partial
    = PARTIAL     {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_encapsulated 
    = ENCAPSULATED {: return newTrue();  :}
    | /* blank */  {: return newFalse(); :}
    ;

Bool has_inner
    = INNER       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_outer
    = OUTER       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_redeclare
    = REDECLARE   {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_each
    = EACH        {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_final
    = FINAL       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

RedeclareReplaceableHeader redeclare_replaceable_header
    = REDECLARE 
      has_each
      has_final 
      REPLACEABLE 
    {:
        return new RedeclareReplaceableHeader(true, has_each.value, has_final.value);
    :}
    | has_each
      has_final 
      REPLACEABLE 
    {:
        adjustStart(has_each, has_final, REPLACEABLE);
        return new RedeclareReplaceableHeader(false, has_each.value, has_final.value);
    :}
    ;


List clause_star
    = default_element_list
    {:
        return new List(default_element_list);
    :}
    | /* blank */
    {: 
        return new List();
    :}
    | clause_star
      clause
    {:
        return clause_star.add(clause);
    :}
    ;

SrcDefaultElementList default_element_list
    = element_plus
    {:
        return new SrcDefaultElementList(element_plus);
    :}
    ;

List element_plus
    = element
    {:
        return new List(element); 
    :} 
    | element_plus 
      element
    {: 
        return element_plus.add(element);
    :}
    ;


SrcClause clause
    = PUBLIC
      element*
    {:
        return new SrcPublicElementList(element);
    :}
    | PROTECTED
      element*
    {:
        return new SrcProtectedElementList(element);
    :}
    | EQUATION
      abstract_equation*
    {:
        return new SrcEquationClause(abstract_equation);
    :}
    | INITIAL_EQUATION
      abstract_equation*
    {:
        return new SrcInitialEquationClause(abstract_equation);
    :}
    | ALGORITHM
      statement*
    {:
        return new SrcAlgorithm(statement);
    :}
    | INITIAL_ALGORITHM
      statement*
    {:
        return new SrcInitialAlgorithm(statement);
    :}
    ;


SrcExternalClause external_clause 
    = EXTERNAL
      external_language?
      external_function_call?
      annotation?
      SEMICOLON
    {:
        return new SrcExternalClause(external_language, external_function_call, annotation);
    :}
    ;

SrcExternalLanguage external_language
    = STRING.s    {: return new SrcExternalLanguage(s); :}
    ;

SrcAnnotation class_annotation 
    = annotation 
      SEMICOLON 
    {:
        return annotation;
    :}
    ;

SrcExternalFunctionCall external_function_call
    = access
      EQUALS
      id_decl
      LPAREN
      arg_list
      RPAREN
    {:
        return new SrcExternalFunctionCall(new Opt(access), id_decl, arg_list);
    :}
    | id_decl
      LPAREN
      arg_list
      RPAREN
    {:
        return new SrcExternalFunctionCall(new Opt(), id_decl, arg_list);
    :}
    ;


SrcElement element 
    = has_redeclare
      has_final 
      has_inner 
      has_outer 
      base_class_decl 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, base_class_decl);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        return base_class_decl;
    :}
    | has_redeclare
      has_final 
      has_inner 
      has_outer 
      REPLACEABLE
      base_class_decl
      constraining_clause_and_comment 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        base_class_decl.setReplaceable(true);
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause_and_comment.constr);
        base_class_decl.setConstrainingClauseComment(constraining_clause_and_comment.comment);
        return base_class_decl;
    :}  
    | extends_clause SEMICOLON 
    {: 
        return extends_clause;
    :}
    | import_clause SEMICOLON 
    {: 
        return import_clause;
    :}
    | has_redeclare
      has_final 
      has_inner 
      has_outer 
      type_prefixes 
      access_scalar 
      array_subscripts? 
      component_list 
      SEMICOLON 
    {:
        adjustStart(has_redeclare, has_final, has_inner, has_outer, type_prefixes, access_scalar);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            false,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            new Opt(),
            new SrcComment());
    :}
    | has_redeclare 
      has_final 
      has_inner 
      has_outer 
      REPLACEABLE 
      type_prefixes 
      access_scalar 
      array_subscripts? 
      component_list 
      constraining_clause_and_comment 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            true,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            constraining_clause_and_comment.constr,
            constraining_clause_and_comment.comment);
    :}
    | error SEMICOLON
    {: 
        return new SrcBadElement();
    :}
    ;

ConstrClauseAndComment constraining_clause_and_comment
    = constraining_clause
      comment
    {:
        return new ConstrClauseAndComment(constraining_clause, comment);
    :}
    | /* blank */
    {:
        return new ConstrClauseAndComment();
    :}
    ;

SrcConstrainingClause constraining_clause 
    = CONSTRAINEDBY 
      access 
      class_modification?
    {: 
        return new SrcConstrainingClause(access, class_modification);
    :}
    ;

SrcExtendsClause extends_clause 
    = EXTENDS 
      access 
      class_modification? 
      annotation?
    {: 
        return new SrcExtendsClause(access, class_modification, annotation);
    :}
  ;

SrcImportClause import_clause
    = IMPORT
      access_scalar
      comment
    {:
        return new SrcImportClauseQualified(access_scalar, comment);
    :}
    | IMPORT
      access_scalar
      DOTMULT
      comment
    {:
        return new SrcImportClauseUnqualified(access_scalar, comment);
    :}
    | IMPORT
      id_decl.alias
      EQUALS
      access_scalar
      comment
    {:
        return new SrcImportClauseRename(access_scalar, comment, alias);
    :}
    ;


SrcArraySubscripts array_subscripts
    = LBRACK
      subscript_list
      RBRACK
    {:
        return new SrcArraySubscripts(subscript_list);
    :}
    ;

List subscript_list
    = subscript
    {:
        return new List().add(subscript);
    :}
    | subscript_list
      COMMA
      subscript
    {:
        subscript_list.add(subscript);
        return subscript_list;
    :}
    ;

SrcSubscript subscript 
    = COLON   {: return new SrcColonSubscript();  :}
    | exp     {: return new SrcExpSubscript(exp); :}
    ;


List component_list
    = component_decl
    {:
        return new List(component_decl);
    :}
    | component_list
      COMMA
      component_decl
    {:
        component_list.add(component_decl);
        return component_list;
    :}
    ;

SrcComponentDecl component_decl
    = id_decl.comp_name
      array_subscripts?
      modification?
      conditional_attribute?
      comment
    {:
        return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 conditional_attribute, 
                                 comment);
    :}
    ;

SrcComponentDecl component_decl_no_conditional
    = id_decl.comp_name
      array_subscripts?
      modification?
      comment
    {:
        return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 new Opt(), 
                                 comment);
    :}
    ;

SrcConditionalAttribute conditional_attribute
    = IF exp    {: return new SrcConditionalAttribute(exp); :}
    ;

SrcModification modification 
    = complete_modification   {: return complete_modification; :}
    | value_modification      {: return value_modification;    :}
// Assign modification for binding equations in functions - enable after figuring out 
// a good way to make it an error outside of functions. Preferably parse error, but that 
// likely requires much more code duplication then we want to accept.
//  | assign_modification     {: return assign_modification;   :}
    ;


SrcCompleteModification complete_modification
    = class_modification
      value_modification?
    {:
        return new SrcCompleteModification(class_modification, value_modification);
    :}
    ;
  
SrcValueModification value_modification
    = EQUALS exp          {: return new SrcValueModification(exp); :}
    | COLON EQUALS exp    {: return new SrcValueModification(exp); :}
    ;

/*  
// Assign modification for binding equations in functions - enable after figuring out 
// a good way to make it an error outside of functions. Preferably parse error, but that 
// likely requires much more code duplication than we want to accept.
AssignModification assign_modification
    = COLON EQUALS exp    {: return new AssignModification(exp); :}
    ;
*/

SrcClassModification class_modification
    = LPAREN
      RPAREN
    {:
        return new SrcClassModification();
    :}
    | LPAREN
      argument_list
      RPAREN
    {:
        return new SrcClassModification(argument_list);
    :}
    ;

List argument_list
    = argument
    {:
        return new List().add(argument);
    :}
    | argument_list
      COMMA
      argument
    {:
        argument_list.add(argument);
        return argument_list;
    :}
    ;

SrcArgument argument
    = has_each 
      has_final 
      access 
      modification? 
      comment
    {: 
        adjustStart(has_each, has_final, access);
        return new SrcComponentModification(
            has_each.value, 
            has_final.value, 
            access, 
            modification, 
            comment);
    :}
    | redeclare_replaceable_header 
      base_class_decl 
      constraining_clause?
    {:
        adjustStart(redeclare_replaceable_header, base_class_decl);
        SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause);
        base_class_decl.setReplaceable(true);
        base_class_decl.setRedeclare(redeclare_replaceable_header.has_redeclare);
        return new SrcClassRedeclare(
            redeclare_replaceable_header.has_each, 
            redeclare_replaceable_header.has_final, 
            name, 
            base_class_decl);
    :} 
    | REDECLARE 
      has_each 
      has_final  
      base_class_decl 
    {: 
        SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setRedeclare(true);
        return new SrcClassRedeclare(
            has_each.value,
            has_final.value,
            name,
            base_class_decl);
    :}
    | redeclare_replaceable_header.header 
      component_clause_in_argument.cc
      constraining_clause.constr? 
    {:
        adjustStart(header, cc);
        cc.setSrcConstrainingClauseOpt(constr);
        cc.setLocationNoTree(header, (constr.hasChild() ? constr : cc));
        cc.setRedeclare(header.has_redeclare);
        return new SrcComponentRedeclare(
            header.has_each, 
            header.has_final, 
            cc.createAccessForRedeclareNode(),
            cc); 
    :}
    | REDECLARE 
      has_each 
      has_final 
      component_clause_in_argument.cc
    {: 
        cc.setReplaceable(false);
        cc.setLocationNoTree(REDECLARE, cc);
        return new SrcComponentRedeclare(
            has_each.value, 
            has_final.value, 
            cc.createAccessForRedeclareNode(),
            cc); 
    :}
    | error 
    {: 
        return new SrcBadArgument();
    :}
    ;

SrcComponentClause component_clause_in_argument
    = type_prefixes 
      access_scalar 
      component_decl_no_conditional
    {:
        adjustStart(type_prefixes, access_scalar);
        return new SrcComponentClause(
            true,   // Changed in argument rule for case without "redeclare"
            false, 
            false, 
            false, 
            true,   // Changed in argument rule for case without "replaceable"
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            access_scalar, 
            new Opt(), 
            new List(component_decl_no_conditional), 
            new Opt(), 
            new SrcComment());
    :}
    ;

SrcAnnotation annotation
    = annotation_tok
      class_modification
    {:
        annotationTok = null;
        return new SrcParseAnnotation(class_modification);
    :}
    ;

Symbol annotation_tok
    = ANNOTATION
    {:
        if (annotationTok != null) {
            getReport().syntaxError(ANNOTATION);
        }
        annotationTok = ANNOTATION;
        return new Symbol(ANNOTATION);
    :}
    ;

SrcAbstractEquation abstract_equation
    = exp.left
      EQUALS 
      exp.right 
      comment 
      SEMICOLON
    {: 
        return new SrcEquation(comment, left, right);
    :}
    | if_equation 
      SEMICOLON
    {:
        return if_equation;
    :}
    | for_clause_e 
      SEMICOLON
    {:
        return for_clause_e;
    :}
    | when_equation 
      SEMICOLON
    {:
        return when_equation;
    :}
    | CONNECT
      LPAREN
      access.a
      COMMA
      access.b
      RPAREN
      comment
      SEMICOLON
    {:
        return new SrcConnectClause(comment, a, b);
    :}
    | LPAREN 
      function_call_left_list
      RPAREN
      EQUALS
      function_call
      comment
      SEMICOLON
    {:
        return new SrcFunctionCallEquation(comment, function_call_left_list, function_call);
    :}
    | function_call
      comment
      SEMICOLON
    {:
        return new SrcFunctionCallEquation(comment, new List(), function_call);
    :}
    ;

List function_call_left_list
    = function_call_left.a
      COMMA
      function_call_left.b
    {: 
        return new List().add(a).add(b);
    :}
    | function_call_left_list
      COMMA
      function_call_left
    {:
        return function_call_left_list.add(function_call_left);
    :}
    ;

SrcFunctionCallLeft function_call_left
    = /* blank */  {: return new SrcFunctionCallLeft(); :}
    | access       {: return new SrcFunctionCallLeft(new Opt(access)); :}
    ;

SrcForClauseE for_clause_e
    = FOR
      for_indices
      LOOP
      abstract_equation*
      END_FOR
      comment
    {:
        return new SrcForClauseE(comment, for_indices,abstract_equation);
    :}
    ;


List for_indices
    = for_index
    {:
        return new List().add(for_index);
    :}
    | for_indices
      COMMA
      for_index
    {:
        for_indices.add(for_index);
        return for_indices;
    :}
    ;

SrcForIndex for_index
    = for_index_decl for_in_exp?
    {: 
        SrcForIndex f = new SrcForIndex(
            false,
            false,
            false,
            false,
            false,
            new Opt(),
            new Opt(new SrcIndexParameter()),
            new Opt(),
            new SrcNamedAccess("Integer"),
            new Opt(),
            new List(for_index_decl),
            new Opt(),
            new SrcComment(),
            for_in_exp); 
        return f; 
    :}
    ;

SrcForIndexDecl for_index_decl
    = id_decl
    {:
        return new SrcForIndexDecl(
            id_decl,
            new Opt(),
            new Opt(),
            new Opt(),
            new SrcComment());
    :}
    ;

SrcExp for_in_exp
    = IN exp.e    {: return e; :}
    ;

SrcWhenEquation when_equation
    = WHEN
      exp.test
      THEN
      abstract_equation*
      else_when_equation?
      END_WHEN
      comment
    {: 
        return new SrcWhenEquation(comment,
                                abstract_equation,
                                test, 
                                else_when_equation); 
    :}
    ;

SrcWhenEquation else_when_equation
    = ELSEWHEN
      exp.test
      THEN
      abstract_equation*
      else_when_equation?
    {: 
        return new SrcWhenEquation(new SrcComment(),
                                abstract_equation, 
                                test, 
                                else_when_equation); 
    :}
  ;

SrcIfEquation if_equation
    = IF
      exp.test
      THEN
      abstract_equation*
      else_if_equation?
      END_IF
      comment
    {:
        return new SrcIfEquation(comment, 
                              abstract_equation, 
                              test, 
                              else_if_equation);
    :}
    ;

SrcIfWhenElseEquation else_if_equation
    = ELSEIF
      exp.test
      THEN
      abstract_equation*
      else_if_equation?
    {:
        return new SrcIfEquation(new SrcComment(),
                              abstract_equation, 
                              test, 
                              else_if_equation);
    :}
    | ELSE
      abstract_equation*
    {:
        return new SrcElseEquation(new SrcComment(), 
                                abstract_equation); 
    :}
    ;


SrcStatement statement
    = access.left ASSIGN exp.right comment SEMICOLON
                                      {: return new SrcAssignStmt(comment, left, right); :}
    | function_call_stmt SEMICOLON    {: return function_call_stmt; :}
    | BREAK comment SEMICOLON         {: return new SrcBreakStmt(comment); :} 
    | RETURN comment SEMICOLON        {: return new SrcReturnStmt(comment); :}
    | if_stmt SEMICOLON               {: return if_stmt; :}
    | when_stmt SEMICOLON             {: return when_stmt; :}
    | for_stmt SEMICOLON              {: return for_stmt; :}
    | while_stmt SEMICOLON            {: return while_stmt; :}
    | error                           {: return new SrcBadStatement(); :}
    ;

SrcFunctionCallStmt function_call_stmt =
    LPAREN function_call_stmt_left_list RPAREN ASSIGN function_call comment  
                           {: return new SrcFunctionCallStmt(comment, function_call_stmt_left_list, function_call); :}
  | function_call comment  {: return new SrcFunctionCallStmt(comment, new List(), function_call); :}
  ;

List function_call_stmt_left_list
    = function_call_left
    {:
        return new List().add(function_call_left);
    :}
    | function_call_stmt_left_list
      COMMA
      function_call_left
    {:
        return function_call_stmt_left_list.add(function_call_left);
    :}
    ;

SrcIfStmt if_stmt =
    IF if_clause_list else_stmts END_IF comment {: return new SrcIfStmt(comment, if_clause_list, new Opt(else_stmts)); :}
  | IF if_clause_list END_IF comment {: return new SrcIfStmt(comment, if_clause_list, new Opt()); :}
  ;  

List if_clause_list =
    if_clause                      {: return new List().add(if_clause); :}
  | if_clause_list else_if_clause  {: return if_clause_list.add(else_if_clause); :}
  ;

SrcIfClause if_clause =
  exp THEN statement*  {: return new SrcIfClause(exp, statement); :}
  ;

SrcIfClause else_if_clause =
  ELSEIF if_clause  {: return if_clause; :}
  ;

SrcElseClause else_stmts =
  ELSE statement*  {: return new SrcElseClause(statement); :}
  ;

SrcWhenStmt when_stmt =
  WHEN when_clause_list END_WHEN comment {: return new SrcWhenStmt(comment, when_clause_list); :}
  ;  

List when_clause_list =
    when_clause                        {: return new List().add(when_clause); :}
  | when_clause_list else_when_clause  {: return when_clause_list.add(else_when_clause); :}
  ;

SrcWhenClause when_clause =
  exp THEN statement*  {: return new SrcWhenClause(exp, statement); :}
  ;

SrcWhenClause else_when_clause =
  ELSEWHEN exp THEN statement*  {: return new SrcWhenClause(exp, statement); :}
  ;

SrcForStmt for_stmt =
  FOR for_indices LOOP statement* END_FOR comment  
                         {: return new SrcForStmt(comment, for_indices, statement); :}
  ;

SrcWhileStmt while_stmt = 
  WHILE exp LOOP statement* END_WHILE comment  {: return new SrcWhileStmt(comment, exp, statement); :}
  ;
  
SrcExp exp =
  simple_expression {: return simple_expression; :}
  | if_exp           {: return if_exp; :}
  ;

SrcIfExp if_exp =
  IF exp.ifexp THEN exp.thenexp else_if_exp 
  		{: return new SrcIfExp(ifexp, thenexp, else_if_exp); :}
  ;  

SrcExp else_if_exp =
   ELSEIF exp.ifexp THEN exp.thenexp else_if_exp 
		{: return new SrcIfExp(ifexp, thenexp, else_if_exp); :}
 | ELSE exp   {: return exp; :}
  ;

SrcExp simple_expression = 
    log_exp 
        {: return log_exp; :}
  | log_exp.l1 COLON log_exp.l2
        {: SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           return r; :}
  | log_exp.l1 COLON log_exp.l2 COLON log_exp.l3
        {: SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           r.addSrcExp(l3);
           return r; :}
  ;

SrcExp log_exp = 
  log_exp.a OR log_exp.b {: return new SrcOrExp(a,b); :}  
  | log_exp.a AND log_exp.b {: return new SrcAndExp(a,b); :}  
  | NOT relation.a {: return new SrcNotExp(a); :}  
  | relation {: return relation; :}
;

SrcExp relation =
  artm_exp.a LT artm_exp.b {: return new SrcLtExp(a,b); :}
  | artm_exp.a LEQ artm_exp.b {: return new SrcLeqExp(a,b); :}
  | artm_exp.a GT artm_exp.b {: return new SrcGtExp(a,b); :}
  | artm_exp.a GEQ artm_exp.b {: return new SrcGeqExp(a,b); :}
  | artm_exp.a EQ artm_exp.b {: return new SrcEqExp(a,b); :}
  | artm_exp.a NEQ artm_exp.b {: return new SrcNeqExp(a,b); :}
  | artm_exp.a {: return a; :}	
  ;
  
  
  SrcExp artm_exp =
   additive_exp {: return additive_exp; :}
   ;

  SrcExp additive_exp =
     multiplicative_exp.e    {: return e; :}
   | additive_exp.e1 PLUS multiplicative_exp.e2      {: return new SrcAddExp(e1, e2); :}
   | additive_exp.e1 MINUS multiplicative_exp.e2     {: return new SrcSubExp(e1, e2); :}
   | additive_exp.e1 DOTPLUS multiplicative_exp.e2   {: return new SrcDotAddExp(e1, e2); :}
   | additive_exp.e1 DOTMINUS multiplicative_exp.e2  {: return new SrcDotSubExp(e1, e2); :}
   ;

  SrcExp multiplicative_exp =
     unary_exp.e                                     {: return e; :}
   | multiplicative_exp.e1 MULT unary_exp.e2     {: return new SrcMulExp(e1, e2); :}
   | multiplicative_exp.e1 DIV unary_exp.e2      {: return new SrcDivExp(e1, e2); :}
   | multiplicative_exp.e1 DOTMULT unary_exp.e2  {: return new SrcDotMulExp(e1, e2); :}
   | multiplicative_exp.e1 DOTDIV unary_exp.e2   {: return new SrcDotDivExp(e1, e2); :} 
   ;


SrcExp unary_exp =
   pow_exp          {: return pow_exp; :}
   | MINUS unary_exp       {: return new SrcNegExp(unary_exp); :}
   | PLUS unary_exp        {: formattingRecorder.addItem(FormattingType.NON_BREAKING_WHITESPACE, "+", PLUS);
                              return unary_exp; :}
   ;

SrcExp pow_exp =
    primary {:return primary; :}
    | primary.a POW primary.e    {: return new SrcPowExp(a,e); :}
    | primary.a DOTPOW primary.e {: return new SrcDotPowExp(a,e); :}
    ;

SrcExp primary =        
   UNSIGNED_NUMBER.n    {: return new SrcRealLitExp(n); :}
  | UNSIGNED_INTEGER.n    {: return new SrcIntegerLitExp(n); :}
  | TRUE                {: return new SrcBooleanLitExpTrue(); :}
  | FALSE                {: return new SrcBooleanLitExpFalse(); :}
  | STRING.s               {: return new SrcStringLitExp(s); :}
  | access_expression   {: return access_expression; :}
  | der_expression      {: return der_expression; :}
  | LPAREN exp.a RPAREN {: return new SrcParExp(a); :}
  | function_call        {: return function_call; :}
  | LBRACK matrix RBRACK {: return matrix; :}
  | LBRACE function_arguments RBRACE {: return new SrcArrayConstructor(function_arguments); :}
  | TIME                {: return new SrcTimeExp(); :}
  | END                 {: return new SrcEndExp(); :} 
  ;

SrcFunctionCall function_call 
    = access
      LPAREN
      function_arguments?
      RPAREN
    {:
        return new SrcFunctionCall(access, function_arguments);
    :}
    ;

SrcPartialFunctionCall partial_function_call
    = FUNCTION
      access
      LPAREN
      function_arguments_named?
      RPAREN
    {:
        return new SrcPartialFunctionCall(access, function_arguments_named);
    :}
    | FUNCTION
      access
    {:
        return new SrcPartialFunctionCall(access, new Opt());
    :}
    ;

SrcFunctionArguments function_arguments =
    exp FOR for_indices               {: List arg_list_f = new List().add(new SrcIterExp(exp, for_indices));
                                         return new SrcFunctionArguments(arg_list_f, new List()); :} 
  | arg_list_p                        {: return new SrcFunctionArguments(arg_list_p, new List()); :}  
  | arg_list_p COMMA named_arguments  {: return new SrcFunctionArguments(arg_list_p, named_arguments); :}
  | function_arguments_named
  ;
  
SrcFunctionArguments function_arguments_named =
  named_arguments {: return new SrcFunctionArguments(new List(), named_arguments); :}
  ;
  
List named_arguments =
    named_argument                       {: return new List().add(named_argument); :}
  | named_arguments COMMA named_argument {: return named_arguments.add(named_argument); :}
  ;
  
SrcExp function_argument_exp =
 exp                               {: return exp; :}
 | partial_function_call          {: return partial_function_call; :}  
 ;
  
SrcNamedArgument named_argument =
  named_argument_id EQUALS function_argument_exp {: return new SrcNamedArgument(named_argument_id,function_argument_exp); :}
  ;

SrcAccess named_argument_id = 
  ID.id {: return new SrcNamedAccess(id); :}
  ;

SrcMatrix matrix = 
    matrix_row                   {: return new SrcMatrix(new List().add(matrix_row)); :}
  | matrix SEMICOLON matrix_row  {: matrix.addRow(matrix_row); 
                                    return matrix; :}      
  ;  
  
SrcMatrixRow matrix_row = 
    exp                   {: return new SrcMatrixRow(new List().add(exp)); :}
  | matrix_row COMMA exp  {: matrix_row.addSrcExp(exp); 
                             return matrix_row; :}
  ; 
  
List arg_list = 
                        {: return new List(); :}
  | exp                 {: return new List().add(exp); :}
  | arg_list COMMA exp  {: arg_list.add(exp); 
                           return arg_list; :}
  ;
  
List arg_list_p = 
  function_argument_exp                   {: return new List().add(function_argument_exp); :}
  | arg_list_p COMMA function_argument_exp  {: return arg_list_p.add(function_argument_exp); :}
  ;
  
SrcComment comment = 
  string_comment?  annotation?     {: return new SrcComment(string_comment,annotation); :}
  ;
  
SrcStringComment string_comment =
  string_comment_exp    {: return new SrcStringComment(string_comment_exp); :}
  ;

SrcExp string_comment_exp
  = string      
  | string_comment_exp PLUS string {: return new SrcAddExp(string_comment_exp, string); :}
  ;

 SrcStringLitExp string =
  STRING.s  {: return new SrcStringLitExp(s); :}
  ;

 SrcIdDecl id_decl = 
   ID.id   {: return new SrcIdDecl(id); :}
 ;

SrcAccessExp access_expression
    = access {: return new SrcAccessExp(access); :}
    ;

SrcDerExp der_expression
    = DER LPAREN exp RPAREN  {: return new SrcDerExp(exp); :}
    ;

SrcAccess access
    = access_loc      {: return access_loc; :}
    | DOT access_loc  {: return new SrcGlobalAccess(access_loc); :}
    ;

SrcAccess access_loc
    = access_single
    | access_dot
    ;

SrcDot access_dot
    = access_single.a
      DOT
      access_single.b
    {:
        return new SrcDot(new List(a, b));
    :}
    | access_dot
      DOT
      access_single
    {:
        access_dot.addSrcNamedAccess(access_single);
        return access_dot;
    :}
    ;

SrcNamedAccess access_single
    = access_single_array
    | access_single_scalar
    ;

SrcArrayAccess access_single_array
    = ID.id array_subscripts  {: return new SrcArrayAccess(id, array_subscripts); :}
    ;

SrcNamedAccess access_single_scalar
    = ID.id  {: return new SrcNamedAccess(id); :}
    ;


SrcAccess access_scalar
    = access_scalar_loc      {: return access_scalar_loc; :}
    | DOT access_scalar_loc  {: return new SrcGlobalAccess(access_scalar_loc); :}
    ;

SrcAccess access_scalar_loc
    = access_scalar_dot
    | access_single_scalar
    ;

SrcDot access_scalar_dot
    = access_single_scalar.a
      DOT
      access_single_scalar.b
    {:
        return new SrcDot(new List(a, b));
    :}
    | access_scalar_dot
      DOT
      access_single_scalar
    {:
        access_scalar_dot.addSrcNamedAccess(access_single_scalar);
        return access_scalar_dot;
    :}
    ;

SrcEndDecl end_decl
    = END_ID
    {:
        String value = (String) END_ID.value;
        String id = value.substring(3, value.length()).trim();
        return new SrcEndDecl(id);
    :}
    ;